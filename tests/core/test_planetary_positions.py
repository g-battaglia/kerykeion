"""
Parametrized tests for planetary positions.

This module tests that planetary positions match expected values across:
- Multiple time periods (100 AD to 2200 AD)
- Multiple geographic locations
- All core planets (Sun through Pluto)
- Lunar nodes
- Chart angles (ASC, MC, etc.)

Tests are data-driven using expected_positions.py as the baseline.
"""

import pytest
from pytest import approx
from typing import Dict, Any, List

from kerykeion import AstrologicalSubjectFactory

from tests.data.test_subjects_matrix import (
    TEMPORAL_SUBJECTS,
    GEOGRAPHIC_SUBJECTS,
    CORE_PLANETS,
    LUNAR_NODES,
    ANGLES,
    get_subject_by_id,
)

# Import expected data - will be generated by regenerate_all.py
try:
    from tests.data.expected_positions import EXPECTED_POSITIONS
except ImportError:
    EXPECTED_POSITIONS = {}
    pytest.skip(
        "Expected positions not generated. Run: python scripts/regenerate_all.py --positions", allow_module_level=True
    )


# =============================================================================
# FIXTURES
# =============================================================================

# Filter out subjects that don't have expected data
VALID_TEMPORAL_IDS = [s["id"] for s in TEMPORAL_SUBJECTS if s["id"] in EXPECTED_POSITIONS]
VALID_GEOGRAPHIC_IDS = [s["id"] for s in GEOGRAPHIC_SUBJECTS if s["id"] in EXPECTED_POSITIONS]


@pytest.fixture(params=VALID_TEMPORAL_IDS)
def temporal_subject_id(request) -> str:
    """Parametrized fixture for temporal subject IDs with expected data."""
    return request.param


@pytest.fixture(params=VALID_GEOGRAPHIC_IDS)
def geographic_subject_id(request) -> str:
    """Parametrized fixture for geographic subject IDs with expected data."""
    return request.param


@pytest.fixture(params=CORE_PLANETS)
def planet(request) -> str:
    """Parametrized fixture for core planets."""
    return request.param


@pytest.fixture(params=LUNAR_NODES)
def lunar_node(request) -> str:
    """Parametrized fixture for lunar nodes."""
    return request.param


@pytest.fixture(params=ANGLES)
def angle(request) -> str:
    """Parametrized fixture for angles."""
    return request.param


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================


def create_subject_from_id(subject_id: str):
    """Create an astrological subject from its ID in the test matrix."""
    # Check temporal subjects first
    for data in TEMPORAL_SUBJECTS:
        if data["id"] == subject_id:
            return AstrologicalSubjectFactory.from_birth_data(
                name=data["name"],
                year=data["year"],
                month=data["month"],
                day=data["day"],
                hour=data["hour"],
                minute=data["minute"],
                lat=data["lat"],
                lng=data["lng"],
                tz_str=data["tz_str"],
                online=False,
                suppress_geonames_warning=True,
            )

    # Check geographic subjects
    for data in GEOGRAPHIC_SUBJECTS:
        if data["id"] == subject_id:
            return AstrologicalSubjectFactory.from_birth_data(
                name=f"Test_{data['id']}",
                year=1990,
                month=6,
                day=15,
                hour=12,
                minute=0,
                lat=data["lat"],
                lng=data["lng"],
                tz_str=data["tz_str"],
                online=False,
                suppress_geonames_warning=True,
            )

    raise ValueError(f"Subject ID '{subject_id}' not found in test matrix")


# =============================================================================
# TOLERANCE CONSTANTS
# =============================================================================

POSITION_ABS_TOL = 1e-2  # 0.01 degrees (36 arcseconds)
SPEED_ABS_TOL = 1e-4  # 0.0001 degrees/day
DECLINATION_ABS_TOL = 1e-2  # 0.01 degrees


# =============================================================================
# PARAMETRIZED TESTS - TEMPORAL SUBJECTS x PLANETS
# =============================================================================


class TestTemporalPlanetaryPositions:
    """
    Test planetary positions across different time periods.

    These tests validate that the ephemeris calculations produce consistent
    results for subjects from 100 AD through 2200 AD.
    """

    def test_planet_abs_pos(self, temporal_subject_id: str, planet: str):
        """Test absolute position (0-360) for each planet."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data:
            pytest.skip(f"No expected data for {planet} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.abs_pos == approx(planet_data["abs_pos"], abs=POSITION_ABS_TOL), (
            f"{temporal_subject_id}/{planet}: abs_pos mismatch"
        )

    def test_planet_position(self, temporal_subject_id: str, planet: str):
        """Test position within sign (0-30) for each planet."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data:
            pytest.skip(f"No expected data for {planet} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.position == approx(planet_data["position"], abs=POSITION_ABS_TOL), (
            f"{temporal_subject_id}/{planet}: position mismatch"
        )

    def test_planet_sign(self, temporal_subject_id: str, planet: str):
        """Test zodiac sign for each planet."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data:
            pytest.skip(f"No expected data for {planet} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.sign == planet_data["sign"], (
            f"{temporal_subject_id}/{planet}: sign mismatch - got {actual_point.sign}, expected {planet_data['sign']}"
        )

    def test_planet_retrograde(self, temporal_subject_id: str, planet: str):
        """Test retrograde status for each planet."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data or "retrograde" not in planet_data:
            pytest.skip(f"No retrograde data for {planet} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.retrograde == planet_data["retrograde"], (
            f"{temporal_subject_id}/{planet}: retrograde mismatch"
        )

    def test_planet_speed(self, temporal_subject_id: str, planet: str):
        """Test planetary speed (degrees/day)."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data or "speed" not in planet_data:
            pytest.skip(f"No speed data for {planet} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.speed == approx(planet_data["speed"], abs=SPEED_ABS_TOL), (
            f"{temporal_subject_id}/{planet}: speed mismatch"
        )


class TestGeographicPlanetaryPositions:
    """
    Test planetary positions across different geographic locations.

    These tests validate that planetary positions are consistent across
    various latitudes and longitudes, including edge cases like:
    - Polar regions (66°N/S)
    - Equator (0°)
    - International Date Line
    """

    def test_planet_abs_pos(self, geographic_subject_id: str, planet: str):
        """Test absolute position for each planet at different locations."""
        expected = EXPECTED_POSITIONS.get(geographic_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data:
            pytest.skip(f"No expected data for {planet} in {geographic_subject_id}")

        subject = create_subject_from_id(geographic_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.abs_pos == approx(planet_data["abs_pos"], abs=POSITION_ABS_TOL), (
            f"{geographic_subject_id}/{planet}: abs_pos mismatch"
        )

    def test_planet_sign(self, geographic_subject_id: str, planet: str):
        """Test zodiac sign for each planet at different locations."""
        expected = EXPECTED_POSITIONS.get(geographic_subject_id, {})
        planet_data = expected.get("planets", {}).get(planet, {})

        if not planet_data:
            pytest.skip(f"No expected data for {planet} in {geographic_subject_id}")

        subject = create_subject_from_id(geographic_subject_id)
        actual_point = getattr(subject, planet)

        assert actual_point.sign == planet_data["sign"], f"{geographic_subject_id}/{planet}: sign mismatch"


# =============================================================================
# ANGLE TESTS
# =============================================================================


class TestAngles:
    """
    Test chart angles (Ascendant, Descendant, MC, IC).

    Angles are location-dependent, so geographic tests are especially important.
    """

    def test_temporal_angle_position(self, temporal_subject_id: str, angle: str):
        """Test angle positions for temporal subjects."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        angle_data = expected.get("angles", {}).get(angle, {})

        if not angle_data:
            pytest.skip(f"No expected data for {angle} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, angle)

        assert actual_point.abs_pos == approx(angle_data["abs_pos"], abs=POSITION_ABS_TOL), (
            f"{temporal_subject_id}/{angle}: abs_pos mismatch"
        )
        assert actual_point.sign == angle_data["sign"], f"{temporal_subject_id}/{angle}: sign mismatch"

    def test_geographic_angle_position(self, geographic_subject_id: str, angle: str):
        """Test angle positions for geographic subjects."""
        expected = EXPECTED_POSITIONS.get(geographic_subject_id, {})
        angle_data = expected.get("angles", {}).get(angle, {})

        if not angle_data:
            pytest.skip(f"No expected data for {angle} in {geographic_subject_id}")

        subject = create_subject_from_id(geographic_subject_id)
        actual_point = getattr(subject, angle)

        assert actual_point.abs_pos == approx(angle_data["abs_pos"], abs=POSITION_ABS_TOL), (
            f"{geographic_subject_id}/{angle}: abs_pos mismatch"
        )
        assert actual_point.sign == angle_data["sign"], f"{geographic_subject_id}/{angle}: sign mismatch"


# =============================================================================
# LUNAR NODE TESTS
# =============================================================================


class TestLunarNodes:
    """
    Test lunar node positions (Mean and True, North and South).
    """

    def test_temporal_lunar_node_position(self, temporal_subject_id: str, lunar_node: str):
        """Test lunar node positions for temporal subjects."""
        expected = EXPECTED_POSITIONS.get(temporal_subject_id, {})
        node_data = expected.get("lunar_nodes", {}).get(lunar_node, {})

        if not node_data:
            pytest.skip(f"No expected data for {lunar_node} in {temporal_subject_id}")

        subject = create_subject_from_id(temporal_subject_id)
        actual_point = getattr(subject, lunar_node)

        assert actual_point.abs_pos == approx(node_data["abs_pos"], abs=POSITION_ABS_TOL), (
            f"{temporal_subject_id}/{lunar_node}: abs_pos mismatch"
        )
        assert actual_point.sign == node_data["sign"], f"{temporal_subject_id}/{lunar_node}: sign mismatch"


# =============================================================================
# LUNAR PHASE TESTS
# =============================================================================


class TestLunarPhase:
    """
    Test lunar phase calculations.
    """

    @pytest.mark.parametrize("subject_id", VALID_TEMPORAL_IDS[:10])  # First 10 subjects
    def test_lunar_phase_degrees(self, subject_id: str):
        """Test degrees between Sun and Moon for lunar phase."""
        expected = EXPECTED_POSITIONS.get(subject_id, {})
        lunar_phase_data = expected.get("lunar_phase", {})

        if not lunar_phase_data:
            pytest.skip(f"No lunar phase data for {subject_id}")

        subject = create_subject_from_id(subject_id)

        if subject.lunar_phase is None:
            pytest.skip(f"Lunar phase not calculated for {subject_id}")

        assert subject.lunar_phase.degrees_between_s_m == approx(
            lunar_phase_data["degrees_between_s_m"], abs=POSITION_ABS_TOL
        )

    @pytest.mark.parametrize("subject_id", VALID_TEMPORAL_IDS[:10])
    def test_lunar_phase_name(self, subject_id: str):
        """Test lunar phase name (New Moon, Full Moon, etc.)."""
        expected = EXPECTED_POSITIONS.get(subject_id, {})
        lunar_phase_data = expected.get("lunar_phase", {})

        if not lunar_phase_data:
            pytest.skip(f"No lunar phase data for {subject_id}")

        subject = create_subject_from_id(subject_id)

        if subject.lunar_phase is None:
            pytest.skip(f"Lunar phase not calculated for {subject_id}")

        assert subject.lunar_phase.moon_phase_name == lunar_phase_data["moon_phase_name"]


# =============================================================================
# INTEGRATION TESTS - ALL POINTS FOR KEY SUBJECTS
# =============================================================================


class TestKeySubjectsComplete:
    """
    Comprehensive tests for primary test subjects.

    These tests validate all positions for John Lennon, Johnny Depp,
    and Paul McCartney to ensure complete backward compatibility.
    """

    @pytest.mark.parametrize("subject_id", ["john_lennon_1940", "johnny_depp_1963", "paul_mccartney_1942"])
    def test_all_planets(self, subject_id: str):
        """Test all planet positions for key subjects."""
        expected = EXPECTED_POSITIONS.get(subject_id, {})

        if not expected:
            pytest.skip(f"No expected data for {subject_id}")

        subject = create_subject_from_id(subject_id)

        for planet in CORE_PLANETS:
            planet_data = expected.get("planets", {}).get(planet, {})
            if planet_data:
                actual_point = getattr(subject, planet)
                assert actual_point.abs_pos == approx(planet_data["abs_pos"], abs=POSITION_ABS_TOL), (
                    f"{subject_id}/{planet} abs_pos"
                )
                assert actual_point.sign == planet_data["sign"], f"{subject_id}/{planet} sign"

    @pytest.mark.parametrize("subject_id", ["john_lennon_1940", "johnny_depp_1963", "paul_mccartney_1942"])
    def test_all_angles(self, subject_id: str):
        """Test all angles for key subjects."""
        expected = EXPECTED_POSITIONS.get(subject_id, {})

        if not expected:
            pytest.skip(f"No expected data for {subject_id}")

        subject = create_subject_from_id(subject_id)

        for angle in ANGLES:
            angle_data = expected.get("angles", {}).get(angle, {})
            if angle_data:
                actual_point = getattr(subject, angle)
                assert actual_point.abs_pos == approx(angle_data["abs_pos"], abs=POSITION_ABS_TOL), (
                    f"{subject_id}/{angle} abs_pos"
                )
                assert actual_point.sign == angle_data["sign"], f"{subject_id}/{angle} sign"
