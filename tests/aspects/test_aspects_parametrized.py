"""
Parametrized tests for natal and synastry aspects.

This module tests that aspect calculations match expected values across:
- Multiple subjects (John Lennon, Johnny Depp, Paul McCartney)
- Multiple synastry pairs
- All aspect types (conjunction, opposition, trine, etc.)

Tests are data-driven using expected_aspects.py as the baseline.
"""

import pytest
from pytest import approx
from typing import Dict, Any, List

from kerykeion import AstrologicalSubjectFactory
from kerykeion.aspects import AspectsFactory

from tests.data.test_subjects_matrix import (
    TEMPORAL_SUBJECTS,
    SYNASTRY_PAIRS,
    get_primary_test_subjects,
)

# Import expected data - will be generated by regenerate_all.py
try:
    from tests.data.expected_aspects import EXPECTED_NATAL_ASPECTS, EXPECTED_SYNASTRY_ASPECTS
except ImportError:
    EXPECTED_NATAL_ASPECTS = {}
    EXPECTED_SYNASTRY_ASPECTS = {}
    pytest.skip(
        "Expected aspects not generated. Run: python scripts/regenerate_all.py --aspects", allow_module_level=True
    )


# =============================================================================
# TOLERANCE CONSTANTS
# =============================================================================

POSITION_ABS_TOL = 1e-2  # 0.01 degrees (36 arcseconds)
SPEED_ABS_TOL = 1e-2  # For speed values


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================


def create_subject_from_id(subject_id: str):
    """Create an astrological subject from its ID in the test matrix."""
    for data in TEMPORAL_SUBJECTS:
        if data["id"] == subject_id:
            return AstrologicalSubjectFactory.from_birth_data(
                name=data["name"],
                year=data["year"],
                month=data["month"],
                day=data["day"],
                hour=data["hour"],
                minute=data["minute"],
                lat=data["lat"],
                lng=data["lng"],
                tz_str=data["tz_str"],
                online=False,
                suppress_geonames_warning=True,
            )
    raise ValueError(f"Subject ID '{subject_id}' not found in test matrix")


def assert_aspect_matches(actual: Dict[str, Any], expected: Dict[str, Any], context: str = ""):
    """Assert that an actual aspect matches the expected aspect data."""
    prefix = f"{context}: " if context else ""

    # String/exact match fields
    assert actual["p1_name"] == expected["p1_name"], f"{prefix}p1_name mismatch"
    assert actual["p2_name"] == expected["p2_name"], f"{prefix}p2_name mismatch"
    assert actual["aspect"] == expected["aspect"], f"{prefix}aspect type mismatch"
    assert actual["p1"] == expected["p1"], f"{prefix}p1 index mismatch"
    assert actual["p2"] == expected["p2"], f"{prefix}p2 index mismatch"

    # Numeric fields with tolerance
    assert actual["p1_abs_pos"] == approx(expected["p1_abs_pos"], abs=POSITION_ABS_TOL), f"{prefix}p1_abs_pos"
    assert actual["p2_abs_pos"] == approx(expected["p2_abs_pos"], abs=POSITION_ABS_TOL), f"{prefix}p2_abs_pos"
    assert actual["aspect_degrees"] == approx(expected["aspect_degrees"], abs=POSITION_ABS_TOL), (
        f"{prefix}aspect_degrees"
    )
    assert actual["diff"] == approx(expected["diff"], abs=POSITION_ABS_TOL), f"{prefix}diff"
    assert actual["p1_speed"] == approx(expected["p1_speed"], abs=SPEED_ABS_TOL), f"{prefix}p1_speed"
    assert actual["p2_speed"] == approx(expected["p2_speed"], abs=SPEED_ABS_TOL), f"{prefix}p2_speed"

    # Optional orbit field (present in generated data)
    if "orbit" in expected and "orbit" in actual:
        assert actual["orbit"] == approx(expected["orbit"], abs=POSITION_ABS_TOL), f"{prefix}orbit"


# =============================================================================
# FIXTURES
# =============================================================================

# Get subjects that have expected aspect data
VALID_NATAL_SUBJECT_IDS = [sid for sid in get_primary_test_subjects() if sid in EXPECTED_NATAL_ASPECTS]


@pytest.fixture(params=VALID_NATAL_SUBJECT_IDS)
def natal_subject_id(request) -> str:
    """Parametrized fixture for natal subject IDs with expected data."""
    return request.param


# Filter synastry pairs that have expected data
VALID_SYNASTRY_PAIRS = [(s1, s2) for s1, s2 in SYNASTRY_PAIRS if f"{s1}_x_{s2}" in EXPECTED_SYNASTRY_ASPECTS]


@pytest.fixture(params=VALID_SYNASTRY_PAIRS, ids=lambda p: f"{p[0]}_x_{p[1]}")
def synastry_pair(request) -> tuple:
    """Parametrized fixture for synastry pairs with expected data."""
    return request.param


# =============================================================================
# NATAL ASPECT TESTS
# =============================================================================


class TestNatalAspects:
    """
    Test natal (single-chart) aspects.

    These tests validate that aspect calculations match expected values
    for multiple subjects.
    """

    def test_natal_aspects_count(self, natal_subject_id: str):
        """Test that the correct number of aspects are calculated."""
        expected = EXPECTED_NATAL_ASPECTS.get(natal_subject_id, [])
        if not expected:
            pytest.skip(f"No expected natal aspects for {natal_subject_id}")

        subject = create_subject_from_id(natal_subject_id)
        actual_aspects = AspectsFactory.single_chart_aspects(subject).aspects
        actual_aspects = [a.model_dump() for a in actual_aspects]

        assert len(actual_aspects) == len(expected), (
            f"{natal_subject_id}: aspect count mismatch - got {len(actual_aspects)}, expected {len(expected)}"
        )

    def test_natal_aspects_match(self, natal_subject_id: str):
        """Test that all natal aspects match expected values."""
        expected = EXPECTED_NATAL_ASPECTS.get(natal_subject_id, [])
        if not expected:
            pytest.skip(f"No expected natal aspects for {natal_subject_id}")

        subject = create_subject_from_id(natal_subject_id)
        actual_aspects = AspectsFactory.single_chart_aspects(subject).aspects
        actual_aspects = [a.model_dump() for a in actual_aspects]

        for i, expected_aspect in enumerate(expected):
            if i >= len(actual_aspects):
                pytest.fail(f"{natal_subject_id}: Missing aspect at index {i}")

            assert_aspect_matches(actual_aspects[i], expected_aspect, context=f"{natal_subject_id}[{i}]")


class TestNatalAspectsParametrized:
    """
    Parametrized tests for individual aspects.

    These tests allow testing specific aspect indices independently.
    """

    @pytest.mark.parametrize("subject_id", VALID_NATAL_SUBJECT_IDS)
    @pytest.mark.parametrize("aspect_index", range(10))  # First 10 aspects
    def test_natal_aspect_by_index(self, subject_id: str, aspect_index: int):
        """Test individual natal aspects by index."""
        expected = EXPECTED_NATAL_ASPECTS.get(subject_id, [])
        if not expected or aspect_index >= len(expected):
            pytest.skip(f"No expected aspect at index {aspect_index} for {subject_id}")

        subject = create_subject_from_id(subject_id)
        actual_aspects = AspectsFactory.single_chart_aspects(subject).aspects
        actual_aspects = [a.model_dump() for a in actual_aspects]

        if aspect_index >= len(actual_aspects):
            pytest.fail(f"{subject_id}: Missing aspect at index {aspect_index}")

        assert_aspect_matches(
            actual_aspects[aspect_index], expected[aspect_index], context=f"{subject_id}[{aspect_index}]"
        )


# =============================================================================
# SYNASTRY ASPECT TESTS
# =============================================================================


class TestSynastryAspects:
    """
    Test synastry (dual-chart) aspects.

    These tests validate aspect calculations between two different charts.
    """

    def test_synastry_aspects_count(self, synastry_pair: tuple):
        """Test that the correct number of synastry aspects are calculated."""
        subject1_id, subject2_id = synastry_pair
        pair_key = f"{subject1_id}_x_{subject2_id}"

        expected = EXPECTED_SYNASTRY_ASPECTS.get(pair_key, [])
        if not expected:
            pytest.skip(f"No expected synastry aspects for {pair_key}")

        subject1 = create_subject_from_id(subject1_id)
        subject2 = create_subject_from_id(subject2_id)

        actual_aspects = AspectsFactory.dual_chart_aspects(subject1, subject2).aspects
        actual_aspects = [a.model_dump() for a in actual_aspects]

        assert len(actual_aspects) == len(expected), (
            f"{pair_key}: synastry aspect count mismatch - got {len(actual_aspects)}, expected {len(expected)}"
        )

    def test_synastry_aspects_match(self, synastry_pair: tuple):
        """Test that all synastry aspects match expected values."""
        subject1_id, subject2_id = synastry_pair
        pair_key = f"{subject1_id}_x_{subject2_id}"

        expected = EXPECTED_SYNASTRY_ASPECTS.get(pair_key, [])
        if not expected:
            pytest.skip(f"No expected synastry aspects for {pair_key}")

        subject1 = create_subject_from_id(subject1_id)
        subject2 = create_subject_from_id(subject2_id)

        actual_aspects = AspectsFactory.dual_chart_aspects(subject1, subject2).aspects
        actual_aspects = [a.model_dump() for a in actual_aspects]

        for i, expected_aspect in enumerate(expected):
            if i >= len(actual_aspects):
                pytest.fail(f"{pair_key}: Missing synastry aspect at index {i}")

            assert_aspect_matches(actual_aspects[i], expected_aspect, context=f"{pair_key}[{i}]")


# =============================================================================
# ASPECT TYPE TESTS
# =============================================================================


class TestAspectTypes:
    """
    Test that specific aspect types are correctly identified.
    """

    MAJOR_ASPECTS = ["conjunction", "opposition", "trine", "square", "sextile"]

    @pytest.mark.parametrize("subject_id", VALID_NATAL_SUBJECT_IDS)
    def test_major_aspects_present(self, subject_id: str):
        """Test that major aspects are identified in natal charts."""
        subject = create_subject_from_id(subject_id)
        aspects = AspectsFactory.single_chart_aspects(subject).aspects

        aspect_types = {a.aspect for a in aspects}

        # At least one major aspect should be present
        major_found = aspect_types.intersection(self.MAJOR_ASPECTS)
        assert major_found, f"{subject_id}: No major aspects found"

    @pytest.mark.parametrize("subject_id", VALID_NATAL_SUBJECT_IDS)
    def test_aspect_degrees_valid(self, subject_id: str):
        """Test that aspect degrees are valid values."""
        subject = create_subject_from_id(subject_id)
        aspects = AspectsFactory.single_chart_aspects(subject).aspects

        valid_degrees = [0, 30, 36, 40, 45, 51.43, 60, 72, 80, 90, 108, 120, 135, 144, 150, 180]

        for aspect in aspects:
            assert aspect.aspect_degrees in valid_degrees or 0 <= aspect.aspect_degrees <= 180, (
                f"{subject_id}: Invalid aspect_degrees {aspect.aspect_degrees}"
            )


# =============================================================================
# ASPECT MOVEMENT TESTS
# =============================================================================


class TestAspectMovement:
    """
    Test that aspect movement (Applying/Separating/Static) is correctly calculated.
    """

    @pytest.mark.parametrize("subject_id", VALID_NATAL_SUBJECT_IDS)
    def test_aspect_movement_valid_values(self, subject_id: str):
        """Test that aspect movement has valid values."""
        subject = create_subject_from_id(subject_id)
        aspects = AspectsFactory.single_chart_aspects(subject).aspects

        valid_movements = ["Applying", "Separating", "Static"]

        for aspect in aspects:
            assert aspect.aspect_movement in valid_movements, (
                f"{subject_id}: Invalid aspect_movement '{aspect.aspect_movement}' for {aspect.p1_name}-{aspect.p2_name}"
            )

    @pytest.mark.parametrize("subject_id", VALID_NATAL_SUBJECT_IDS)
    def test_aspect_movement_matches_expected(self, subject_id: str):
        """Test that aspect movement matches expected values."""
        expected = EXPECTED_NATAL_ASPECTS.get(subject_id, [])
        if not expected:
            pytest.skip(f"No expected natal aspects for {subject_id}")

        subject = create_subject_from_id(subject_id)
        actual_aspects = AspectsFactory.single_chart_aspects(subject).aspects
        actual_aspects = [a.model_dump() for a in actual_aspects]

        for i, expected_aspect in enumerate(expected):
            if i >= len(actual_aspects):
                break

            if "aspect_movement" in expected_aspect:
                assert actual_aspects[i]["aspect_movement"] == expected_aspect["aspect_movement"], (
                    f"{subject_id}[{i}]: aspect_movement mismatch for "
                    f"{actual_aspects[i]['p1_name']}-{actual_aspects[i]['p2_name']}"
                )


# =============================================================================
# INTEGRATION TESTS
# =============================================================================


class TestAspectIntegration:
    """
    Integration tests for aspect calculations.
    """

    def test_aspect_positions_valid(self):
        """Test that aspect positions are within valid ranges."""
        subject = create_subject_from_id("john_lennon_1940")
        aspects = AspectsFactory.single_chart_aspects(subject).aspects

        for aspect in aspects:
            assert 0 <= aspect.p1_abs_pos < 360, f"p1_abs_pos out of range: {aspect.p1_abs_pos}"
            assert 0 <= aspect.p2_abs_pos < 360, f"p2_abs_pos out of range: {aspect.p2_abs_pos}"
            assert aspect.diff >= 0, f"diff should be non-negative: {aspect.diff}"
            assert aspect.orbit >= 0, f"orbit should be non-negative: {aspect.orbit}"

    def test_aspect_symmetry(self):
        """Test that aspects are not duplicated (A-B same as B-A)."""
        subject = create_subject_from_id("john_lennon_1940")
        aspects = AspectsFactory.single_chart_aspects(subject).aspects

        seen_pairs = set()
        for aspect in aspects:
            pair = tuple(sorted([aspect.p1, aspect.p2]))
            assert pair not in seen_pairs, f"Duplicate aspect between points {aspect.p1} and {aspect.p2}"
            seen_pairs.add(pair)

    def test_synastry_different_from_natal(self):
        """Test that synastry aspects are different from natal aspects."""
        subject1 = create_subject_from_id("john_lennon_1940")
        subject2 = create_subject_from_id("paul_mccartney_1942")

        natal_aspects = AspectsFactory.single_chart_aspects(subject1).aspects
        synastry_aspects = AspectsFactory.dual_chart_aspects(subject1, subject2).aspects

        # Synastry should have different p2_owner for cross-chart aspects
        synastry_p2_owners = {a.p2_owner for a in synastry_aspects}

        assert subject2.name in synastry_p2_owners or len(synastry_aspects) == 0, (
            "Synastry aspects should include second subject as p2_owner"
        )
