<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>kerykeion.utilities.charts.charts_svg API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kerykeion.utilities.charts.charts_svg</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# * TODO: Change the label for language in 2 objects, one for IT and one for ENG.
# * Then change the label for planets like this: planet[&#34;label&#34;] =&gt; planet[language]

import datetime
import json
import kerykeion as kr
import math
import pytz
from pathlib import Path
from string import Template
from typing import Union

# calculation and svg drawing class
class MakeSvgInstance:
    &#34;&#34;&#34;
    Creates the instance that can genearte the chart with the
    function makeSVG().

    There are 2 templates, the extended (default) which has all the
    information and the basic, which has just the chart.

    Parameters:
        - first_obj: First kerykeion object
        - chart_type: Natal, Transit, Composite (Default: Type=&#34;Natal&#34;)
        - second_obj: Second kerykeion object (Not required if type is Natal)
        - new_output_directory: Set the output directory (default: output_directory)
        - template_type: set the template type to include or not the aspects grid, default: extended)
        - lang: language settings (default: &#34;EN&#34;)
        - new_settings_file: Set the settings file (default: kr.config.json)
    &#34;&#34;&#34;

    def __init__(
            self,
            first_obj: kr.KrInstance,
            chart_type: str = &#34;Natal&#34;,
            second_obj: Union[kr.KrInstance, None] = None,
            new_output_directory: Union[str, None] = None,
            template_type: str = &#34;extended&#34;,
            lang: str = &#34;EN&#34;,
            new_settings_file: Union[str, Path, None] = None,
    ):

        # Directories:
        DATADIR = Path(__file__).parent
        self.homedir = Path.home()
    

        if new_output_directory:
            self.output_directory = Path(new_output_directory)
        else:
            self.output_directory = self.homedir

        # Template types:
        if template_type == &#34;basic&#34;:
            self.xml_svg = DATADIR / &#39;templates/basic.xml&#39;
        else:
            self.xml_svg = DATADIR / &#39;templates/extended.xml&#39;

        # SVG Width
        self.natal_width = 772.2
        self.full_width = 1200

        # Settings file:
        if not new_settings_file:
            self.settings_file = DATADIR.parent / &#39;kr.config.json&#39;
        else:
            self.settings_file = Path(new_settings_file)
            

        self.parse_json_settings(self.settings_file, lang)
        self.type = chart_type

        # Kerykeion instance
        self.user = first_obj
        if not hasattr(self.user, &#34;sun&#34;):
            print(f&#34;Generating kerykeion object for {self.user.name}...&#34;)
            self.user.get_all()

        # Make a list for the absolute degrees of the points of the graphic.

        self.points_deg_ut = self.user.planets_degrees + [self.user.houses_degree_ut[0],
                                                          self.user.houses_degree_ut[9], self.user.houses_degree_ut[6],
                                                          self.user.houses_degree_ut[3]]

        # Make a list of the relative degrees of the points in the graphic.

        self.points_deg = []
        for planet in self.user.planets_list:
            self.points_deg.append(planet[&#34;position&#34;])

        self.points_deg = self.points_deg + [self.user.houses_list[0][&#34;position&#34;],
                                             self.user.houses_list[9][&#34;position&#34;], self.user.houses_list[6][&#34;position&#34;],
                                             self.user.houses_list[3][&#34;position&#34;]]

        # Make list of the poits sign.

        self.points_sign = []

        for planet in self.user.planets_list:
            self.points_sign.append(planet[&#34;sign_num&#34;])

        self.points_sign = self.points_sign + [self.user.houses_list[0][&#34;sign_num&#34;],
                                               self.user.houses_list[9][&#34;sign_num&#34;], self.user.houses_list[6][&#34;sign_num&#34;],
                                               self.user.houses_list[3][&#34;sign_num&#34;]]

        # Make a list of poits if they are retrograde or not.

        self.points_retrograde = []

        for planet in self.user.planets_list:
            self.points_retrograde.append(planet[&#34;retrograde&#34;])

        self.points_retrograde = self.points_retrograde + [False,
                                                           False, False, False]

        # Makes the sign number list.

        self.houses_sign_graph = []
        for h in self.user.houses_list:
            self.houses_sign_graph.append(h[&#39;sign_num&#39;])

        if self.type == &#34;Natal&#34;:
            natal_aspects_instance = kr.utilities.NatalAspects(self.user, new_settings_file=self.settings_file)
            self.aspects_list = natal_aspects_instance.get_aspects()

        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

            # Kerykeion instance
            self.t_user = second_obj

            if not hasattr(self.t_user, &#34;sun&#34;):
                print(f&#34;Generating kerykeion object for {self.t_user.name}...&#34;)
                self.t_user.get_all()

            # Make a list for the absolute degrees of the points of the graphic.

            self.t_points_deg_ut = self.t_user.planets_degrees + [self.t_user.houses_degree_ut[0],
                                                                  self.t_user.houses_degree_ut[
                                                                      9], self.t_user.houses_degree_ut[6],
                                                                  self.t_user.houses_degree_ut[3]]

            # Make a list of the relative degrees of the points in the graphic.

            self.t_points_deg = []
            for planet in self.t_user.planets_list:
                self.t_points_deg.append(planet[&#34;position&#34;])

            self.t_points_deg = self.t_points_deg + [self.t_user.houses_list[0][&#34;position&#34;],
                                                     self.t_user.houses_list[9][&#34;position&#34;], self.t_user.houses_list[6][&#34;position&#34;],
                                                     self.t_user.houses_list[3][&#34;position&#34;]]

            # Make list of the poits sign.

            self.t_points_sign = []

            for planet in self.t_user.planets_list:
                self.t_points_sign.append(planet[&#34;sign_num&#34;])

            self.t_points_sign = self.t_points_sign + [self.t_user.houses_list[0][&#34;sign_num&#34;],
                                                       self.t_user.houses_list[9][&#34;sign_num&#34;], self.t_user.houses_list[6][&#34;sign_num&#34;],
                                                       self.t_user.houses_list[3][&#34;sign_num&#34;]]

            # Make a list of poits if they are retrograde or not.

            self.t_points_retrograde = []

            for planet in self.t_user.planets_list:
                self.t_points_retrograde.append(planet[&#34;retrograde&#34;])

            self.t_points_retrograde = self.t_points_retrograde + [False,
                                                                   False, False, False]

            self.t_houses_sign_graph = []
            for h in self.t_user.houses_list:
                self.t_houses_sign_graph.append(h[&#39;sign_num&#39;])

        # screen size
        if self.type == &#34;Natal&#34;:
            self.screen_width = 772.2
        else:
            self.screen_width = 1200
        self.screen_height = 772.2

        # check for home
        self.home_location = self.user.city
        self.home_geolat = self.user.city_lat
        self.home_geolon = self.user.city_long
        self.home_countrycode = self.user.nation
        self.home_timezonestr = self.user.city_tz

        print(f&#39;{self.user.name} birth location: {self.home_location}, {self.home_geolat}, {self.home_geolon}&#39;)

        # default location
        self.location = self.home_location
        self.geolat = float(self.home_geolat)
        self.geolon = float(self.home_geolon)
        self.countrycode = self.home_countrycode
        self.timezonestr = self.home_timezonestr

        # current datetime
        now = datetime.datetime.now()

        # aware datetime object
        dt_input = datetime.datetime(
            now.year, now.month, now.day, now.hour, now.minute, now.second)
        dt = pytz.timezone(self.timezonestr).localize(dt_input)

        # naive utc datetime object
        dt_utc = dt.replace(tzinfo=None) - dt.utcoffset()

        # Default
        self.name = self.user.name
        self.charttype = self.type
        self.year = self.user.utc.year
        self.month = self.user.utc.month
        self.day = self.user.utc.day
        self.hour = self.user.utc.hour + self.user.utc.minute/100
        self.timezone = self.offsetToTz(dt.utcoffset())
        self.altitude = 25
        self.geonameid = None

        # Transit

        if self.type == &#34;Transit&#34;:
            self.t_geolon = self.geolon
            self.t_geolat = self.geolat
            self.t_altitude = self.altitude
            self.t_name = self.language_settings[&#39;transit_name&#39;]
            self.t_year = dt_utc.year
            self.t_month = dt_utc.month
            self.t_day = dt_utc.day
            self.t_hour = self.decHourJoin(
                dt_utc.hour, dt_utc.minute, dt_utc.second)
            self.t_timezone = self.offsetToTz(dt.utcoffset())
            self.t_altitude = 25
            self.t_geonameid = None

        # configuration
        # ZOOM 1 = 100%
        self.zoom = 1

        # 12 zodiacs
        self.zodiac = [&#39;aries&#39;, &#39;taurus&#39;, &#39;gemini&#39;, &#39;cancer&#39;, &#39;leo&#39;, &#39;virgo&#39;,
                       &#39;libra&#39;, &#39;scorpio&#39;, &#39;sagittarius&#39;, &#39;capricorn&#39;, &#39;aquarius&#39;, &#39;pisces&#39;]
        self.zodiac_short = [&#39;Ari&#39;, &#39;Tau&#39;, &#39;Gem&#39;, &#39;Cnc&#39;, &#39;Leo&#39;,
                             &#39;Vir&#39;, &#39;Lib&#39;, &#39;Sco&#39;, &#39;Sgr&#39;, &#39;Cap&#39;, &#39;Aqr&#39;, &#39;Psc&#39;]
        self.zodiac_color = [&#39;#482900&#39;, &#39;#6b3d00&#39;, &#39;#5995e7&#39;, &#39;#2b4972&#39;, &#39;#c54100&#39;,
                             &#39;#2b286f&#39;, &#39;#69acf1&#39;, &#39;#ffd237&#39;, &#39;#ff7200&#39;, &#39;#863c00&#39;, &#39;#4f0377&#39;, &#39;#6cbfff&#39;]
        self.zodiac_element = [&#39;fire&#39;, &#39;earth&#39;, &#39;air&#39;, &#39;water&#39;, &#39;fire&#39;,
                               &#39;earth&#39;, &#39;air&#39;, &#39;water&#39;, &#39;fire&#39;, &#39;earth&#39;, &#39;air&#39;, &#39;water&#39;]

        # get color configuration

        # Immediately generate template.
        self.template = self.makeTemplate()


    def parse_json_settings(self, settings_file, lang: str):
        &#34;&#34;&#34;
        Parse the settings file.
        &#34;&#34;&#34;
        with open(settings_file, &#39;r&#39;) as f:
            settings = json.load(f)

        self.language_settings = settings[&#39;language_settings&#39;].get(
            lang, &#34;EN&#34;)
        self.colors_settings = settings[&#39;colors&#39;]
        self.planets_settings = settings[&#39;planets&#39;]
        self.aspects_settings = settings[&#39;aspects&#39;]

        
    def makeTemplate(self, printing=None):
        # self.type = &#34;Transit&#34;
        # empty element points
        self.fire = 0.0
        self.earth = 0.0
        self.air = 0.0
        self.water = 0.0

        # Transit module data
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            # grab transiting module data

            self.t_planets_sign = self.t_points_sign
            self.t_planets_degree = self.t_points_deg
            self.t_planets_degree_ut = self.t_points_deg_ut
            self.t_planets_retrograde = self.t_points_retrograde
            self.t_houses_list = self.t_user.houses_list
            self.t_houses_sign = self.t_houses_sign_graph
            self.t_houses_degree_ut = self.t_user.houses_degree_ut

        # grab normal module data
        self.planets_sign = self.points_sign
        self.planets_degree = self.points_deg
        self.planets_degree_ut = self.points_deg_ut
        self.planets_retrograde = self.points_retrograde
        self.houses_list = self.user.houses_list
        self.houses_sign = self.houses_sign_graph
        self.houses_degree_ut = self.user.houses_degree_ut
        self.lunar_phase = self.user.lunar_phase
        #

        # width and height from screen
        ratio = float(self.screen_width) / float(self.screen_height)
        if ratio &lt; 1.3:  # 1280x1024
            wm_off = 130
        else:  # 1024x768, 800x600, 1280x800, 1680x1050
            wm_off = 100

        # Viewbox and sizing
        svgHeight = &#34;100%&#34;  # self.screen_height-wm_off
        svgWidth = &#34;100%&#34;  #  self.screen_width-5.0
        # svgHeight=self.screen_height-wm_off
        # svgWidth=(770.0*svgHeight)/540.0
        # svgWidth=float(self.screen_width)-25.0
        rotate = &#34;0&#34;
        translate = &#34;0&#34;
        # Defoult:
        # viewbox = &#39;0 0 772.2 546.0&#39; #297mm * 2.6 + 210mm * 2.6
        if self.type == &#34;Natal&#34;:
            viewbox = &#39;0 0 772.2 546.0&#39;  # 297mm * 2.6 + 210mm * 2.6
        else:
            viewbox = &#39;0 0 1000 546.0&#39;

        # template dictionary
        td = dict()
        r = 240
        self.c1 = 0
        self.c2 = 36
        self.c3 = 120

        # transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            td[&#39;transitRing&#39;] = self.transitRing(r)
            td[&#39;degreeRing&#39;] = self.degreeTransitRing(r)
            # circles
            td[&#39;c1&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-36) + &#39;&#34;&#39;
            td[&#39;c1style&#39;] = &#39;fill: none; stroke: %s; stroke-width: 1px; stroke-opacity:.4;&#39; % (
                self.colors_settings[&#39;zodiac_transit_ring_2&#39;])
            td[&#39;c2&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-72) + &#39;&#34;&#39;
            td[&#39;c2style&#39;] = &#39;fill: %s; fill-opacity:.4; stroke: %s; stroke-opacity:.4; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_transit_ring_1&#39;])
            td[&#39;c3&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-160) + &#39;&#34;&#39;
            td[&#39;c3style&#39;] = &#39;fill: %s; fill-opacity:.8; stroke: %s; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_transit_ring_0&#39;])
            td[&#39;makeAspects&#39;] = self.makeAspectsTransit(r, (r-160))
            td[&#39;makeAspectGrid&#39;] = self.makeAspectTransitGrid(r)
            td[&#39;makePatterns&#39;] = &#39;&#39;
            td[&#39;chart_width&#39;] = self.full_width
        else:
            td[&#39;transitRing&#39;] = &#34;&#34;
            td[&#39;degreeRing&#39;] = self.degreeRing(r)
            # circles
            td[&#39;c1&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c1) + &#39;&#34;&#39;
            td[&#39;c1style&#39;] = &#39;fill: none; stroke: %s; stroke-width: 1px; &#39; % (
                self.colors_settings[&#39;zodiac_radix_ring_2&#39;])
            td[&#39;c2&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c2) + &#39;&#34;&#39;
            td[&#39;c2style&#39;] = &#39;fill: %s; fill-opacity:.2; stroke: %s; stroke-opacity:.4; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_radix_ring_1&#39;])
            td[&#39;c3&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c3) + &#39;&#34;&#39;
            td[&#39;c3style&#39;] = &#39;fill: %s; fill-opacity:.8; stroke: %s; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_radix_ring_0&#39;])
            td[&#39;makeAspects&#39;] = self.makeAspects(r, (r-self.c3))
            td[&#39;makeAspectGrid&#39;] = self.makeAspectGrid(r)
            td[&#39;makePatterns&#39;] = self.makePatterns()
            td[&#39;chart_width&#39;] = self.natal_width

        td[&#39;circleX&#39;] = str(0)
        td[&#39;circleY&#39;] = str(0)
        td[&#39;svgWidth&#39;] = str(svgWidth)
        td[&#39;svgHeight&#39;] = str(svgHeight)
        td[&#39;viewbox&#39;] = viewbox
        if self.type == &#34;Composite&#34;:
            td[&#39;stringTitle&#39;] = f&#34;{self.name} {self.language_settings[&#39;&amp;&#39;]} {self.t_user.name}&#34;
        elif self.type == &#34;Transit&#34;:
            td[&#39;stringTitle&#39;] = f&#34;{self.language_settings[&#39;transits&#39;]} {self.t_user.day}/{self.t_user.month}/{self.t_user.year}&#34;
        else:
            td[&#39;stringTitle&#39;] = self.name

        # Tipo di carta
        if self.type == &#34;Composite&#34; or self.name == &#34;Transit&#34;:
            td[&#39;stringName&#39;] = f&#34;{self.name}:&#34;
        else:
            td[&#39;stringName&#39;] = f&#39;{self.language_settings[&#34;info&#34;]}:&#39;

        # bottom left

        td[&#39;bottomLeft1&#39;] = &#39;&#39;
        td[&#39;bottomLeft2&#39;] = &#39;&#39;
        td[&#39;bottomLeft3&#39;] = f&#39;{self.language_settings.get(&#34;lunar_phase&#34;, &#34;Lunar Phase&#34;)}: {self.language_settings.get(&#34;day&#34;, &#34;Day&#34;)} {self.lunar_phase.get(&#34;moon_phase&#34;, &#34;&#34;)}&#39;
        td[&#39;bottomLeft4&#39;] = &#39;&#39;

        # lunar phase
        deg = self.lunar_phase[&#39;degrees_between_s_m&#39;]

        if(deg &lt; 90.0):
            maxr = deg
            if(deg &gt; 80.0):
                maxr = maxr*maxr
            lfcx = 20.0+(deg/90.0)*(maxr+10.0)
            lfr = 10.0+(deg/90.0)*maxr
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_0&#34;], self.colors_settings[&#34;lunar_phase_1&#34;]

        elif(deg &lt; 180.0):
            maxr = 180.0-deg
            if(deg &lt; 100.0):
                maxr = maxr*maxr
            lfcx = 20.0+((deg-90.0)/90.0*(maxr+10.0))-(maxr+10.0)
            lfr = 10.0+maxr-((deg-90.0)/90.0*maxr)
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_1&#34;], self.colors_settings[&#34;lunar_phase_0&#34;]

        elif(deg &lt; 270.0):
            maxr = deg-180.0
            if(deg &gt; 260.0):
                maxr = maxr*maxr
            lfcx = 20.0+((deg-180.0)/90.0*(maxr+10.0))
            lfr = 10.0+((deg-180.0)/90.0*maxr)
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_1&#34;], self.colors_settings[&#34;lunar_phase_0&#34;]

        elif(deg &lt; 361):
            maxr = 360.0-deg
            if(deg &lt; 280.0):
                maxr = maxr*maxr
            lfcx = 20.0+((deg-270.0)/90.0*(maxr+10.0))-(maxr+10.0)
            lfr = 10.0+maxr-((deg-270.0)/90.0*maxr)
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_0&#34;], self.colors_settings[&#34;lunar_phase_1&#34;]

        td[&#39;lunar_phase_fg&#39;] = lffg
        td[&#39;lunar_phase_bg&#39;] = lfbg
        td[&#39;lunar_phase_cx&#39;] = lfcx
        td[&#39;lunar_phase_r&#39;] = lfr
        td[&#39;lunar_phase_outline&#39;] = self.colors_settings[&#34;lunar_phase_2&#34;]

        # rotation based on latitude
        td[&#39;lunar_phase_rotate&#39;] = (-90.0-self.geolat)

        # stringlocation
        if len(self.location) &gt; 35:
            split = self.location.split(&#34;,&#34;)
            if len(split) &gt; 1:
                td[&#39;stringLocation&#39;] = split[0]+&#34;, &#34;+split[-1]
                if len(td[&#39;stringLocation&#39;]) &gt; 35:
                    td[&#39;stringLocation&#39;] = td[&#39;stringLocation&#39;][:35]+&#34;...&#34;
            else:
                td[&#39;stringLocation&#39;] = self.location[:35]+&#34;...&#34;
        else:
            td[&#39;stringLocation&#39;] = self.location

        # td[&#39;stringDateTime&#39;]= str(self.user.year)+&#39;-%(#1)02d-%(#2)02d %(#3)02d:%(#4)02d:%(#5)02d&#39; % {&#39;#1&#39;:self.user.month,&#39;#2&#39;:self.user.day,&#39;#3&#39;:self.user.hours,&#39;#4&#39;:self.user.minuts,&#39;#5&#39;:00} + self.decTzStr(self.timezone)
        td[&#39;stringDateTime&#39;] = f&#39;{self.user.year}-{self.user.month}-{self.user.day} {self.user.hours:02d}:{self.user.minuts:02d}&#39;

        if self.type == &#34;Composite&#34;:
            td[&#39;stringLat&#39;] = f&#39;{self.t_user.name}: &#39;
            td[&#39;stringLon&#39;] = self.t_user.city
            td[&#39;stringPosition&#39;] = f&#39;{self.t_user.year}-{self.t_user.month}-{self.t_user.day} {self.t_user.hours:02d}:{self.t_user.minuts:02d}&#39;

        else:
            td[&#39;stringLat&#39;] = &#34;%s: %s&#34; % (
                self.language_settings[&#39;latitude&#39;], self.lat2str(self.geolat))
            td[&#39;stringLon&#39;] = &#34;%s: %s&#34; % (
                self.language_settings[&#39;longitude&#39;], self.lon2str(self.geolon))
            td[&#39;stringPosition&#39;] = f&#34;{self.language_settings[&#39;type&#39;]}: {self.charttype}&#34;

        # paper_color_X
        td[&#39;paper_color_0&#39;] = self.colors_settings[&#34;paper_0&#34;]
        td[&#39;paper_color_1&#39;] = self.colors_settings[&#34;paper_1&#34;]

        # planets_color_X
        for i in range(len(self.planets_settings)):
            td[&#39;planets_color_%s&#39; %
                (i)] = self.colors_settings[&#34;planet_%s&#34; % (i)]

        # zodiac_color_X
        for i in range(12):
            td[&#39;zodiac_color_%s&#39; %
                (i)] = self.colors_settings[&#34;zodiac_icon_%s&#34; % (i)]

        # orb_color_X
        for i in range(len(self.aspects_settings)):
            td[&#39;orb_color_%s&#39; % (self.aspects_settings[i][&#39;degree&#39;])] = self.colors_settings[&#34;aspect_%s&#34; % (
                self.aspects_settings[i][&#39;degree&#39;])]

        # config
        td[&#39;cfgZoom&#39;] = str(self.zoom)
        td[&#39;cfgRotate&#39;] = rotate
        td[&#39;cfgTranslate&#39;] = translate

        # functions
        td[&#39;makeZodiac&#39;] = self.makeZodiac(r)
        td[&#39;makeHouses&#39;] = self.makeHouses(r)
        td[&#39;makePlanets&#39;] = self.makePlanets(r)
        td[&#39;makeElements&#39;] = self.makeElements(r)
        td[&#39;makePlanetGrid&#39;] = self.makePlanetGrid()
        td[&#39;makeHousesGrid&#39;] = self.makeHousesGrid()

        # read template
        with open(self.xml_svg, &#34;r&#34;) as output_file:
            f = open(self.xml_svg)
            template = Template(f.read()).substitute(td)

        # return filename

        return template

    def makeSVG(self):
        &#34;&#34;&#34;Prints out the SVG file in the specifide folder&#34;&#34;&#34;

        if not (self.template):
            self.template = self.makeTemplate()

        self.chartname = self.output_directory / f&#39;{self.name}{self.type}Chart.svg&#39;

        with open(self.chartname, &#34;w&#34;, encoding=&#39;utf-8&#39;) as output_file:
            output_file.write(self.template)

        return print(f&#34;SVG Generated Correctly in: {self.chartname}&#34;)

    # draw transit ring
    def transitRing(self, r):
        out = &#39;&lt;circle cx=&#34;%s&#34; cy=&#34;%s&#34; r=&#34;%s&#34; style=&#34;fill: none; stroke: %s; stroke-width: 36px; stroke-opacity: .4;&#34;/&gt;&#39; % (
            r, r, r-18, self.colors_settings[&#39;paper_1&#39;])
        out += &#39;&lt;circle cx=&#34;%s&#34; cy=&#34;%s&#34; r=&#34;%s&#34; style=&#34;fill: none; stroke: %s; stroke-width: 1px; stroke-opacity: .6;&#34;/&gt;&#39; % (
            r, r, r, self.colors_settings[&#39;zodiac_transit_ring_3&#39;])
        return out

    # draw degree ring
    def degreeRing(self, r):
        out = &#39;&#39;
        for i in range(72):
            offset = float(i*5) - self.houses_degree_ut[6]
            if offset &lt; 0:
                offset = offset + 360.0
            elif offset &gt; 360:
                offset = offset - 360.0
            x1 = self.sliceToX(0, r-self.c1, offset) + self.c1
            y1 = self.sliceToY(0, r-self.c1, offset) + self.c1
            x2 = self.sliceToX(0, r+2-self.c1, offset) - 2 + self.c1
            y2 = self.sliceToY(0, r+2-self.c1, offset) - 2 + self.c1
            out += &#39;&lt;line x1=&#34;%s&#34; y1=&#34;%s&#34; x2=&#34;%s&#34; y2=&#34;%s&#34; style=&#34;stroke: %s; stroke-width: 1px; stroke-opacity:.9;&#34;/&gt;\n&#39; % (
                x1, y1, x2, y2, self.colors_settings[&#39;paper_0&#39;])
        return out

    def degreeTransitRing(self, r):
        out = &#39;&#39;
        for i in range(72):
            offset = float(i*5) - self.houses_degree_ut[6]
            if offset &lt; 0:
                offset = offset + 360.0
            elif offset &gt; 360:
                offset = offset - 360.0
            x1 = self.sliceToX(0, r, offset)
            y1 = self.sliceToY(0, r, offset)
            x2 = self.sliceToX(0, r+2, offset) - 2
            y2 = self.sliceToY(0, r+2, offset) - 2
            out += &#39;&lt;line x1=&#34;%s&#34; y1=&#34;%s&#34; x2=&#34;%s&#34; y2=&#34;%s&#34; style=&#34;stroke: #F00; stroke-width: 1px; stroke-opacity:.9;&#34;/&gt;\n&#39; % (
                x1, y1, x2, y2)
        return out

    # floating latitude an longitude to string
    def lat2str(self, coord):
        sign = self.language_settings[&#34;north&#34;]
        if coord &lt; 0.0:
            sign = self.language_settings[&#34;south&#34;]
            coord = abs(coord)
        deg = int(coord)
        min = int((float(coord) - deg) * 60)
        sec = int(round(float(((float(coord) - deg) * 60) - min) * 60.0))
        return &#34;%s°%s&#39;%s\&#34; %s&#34; % (deg, min, sec, sign)

    def lon2str(self, coord):
        sign = self.language_settings[&#34;east&#34;]
        if coord &lt; 0.0:
            sign = self.language_settings[&#34;west&#34;]
            coord = abs(coord)
        deg = int(coord)
        min = int((float(coord) - deg) * 60)
        sec = int(round(float(((float(coord) - deg) * 60) - min) * 60.0))
        return &#34;%s°%s&#39;%s\&#34; %s&#34; % (deg, min, sec, sign)

    # decimal hour to minutes and seconds
    def decHour(self, input):
        hours = int(input)
        mands = (input-hours)*60.0
        mands = round(mands, 5)
        minutes = int(mands)
        seconds = int(round((mands-minutes)*60))
        return [hours, minutes, seconds]

    # join hour, minutes, seconds, timezone integere to hour float
    def decHourJoin(self, inH, inM, inS):
        dh = float(inH)
        dm = float(inM)/60
        ds = float(inS)/3600
        output = dh + dm + ds
        return output

    # Datetime offset to float in hours
    def offsetToTz(self, dtoffset):
        dh = float(dtoffset.days * 24)
        sh = float(dtoffset.seconds / 3600.0)
        output = dh + sh
        return output

    # decimal timezone string
    def decTzStr(self, tz):
        if tz &gt; 0:
            h = int(tz)
            m = int((float(tz)-float(h))*float(60))
            return &#34; [+%(#1)02d:%(#2)02d]&#34; % {&#39;#1&#39;: h, &#39;#2&#39;: m}
        else:
            h = int(tz)
            m = int((float(tz)-float(h))*float(60))/-1
            return &#34; [-%(#1)02d:%(#2)02d]&#34; % {&#39;#1&#39;: h/-1, &#39;#2&#39;: m}

    # degree difference
    def degreeDiff(self, a, b):
        out = float()
        if a &gt; b:
            out = a - b
        if a &lt; b:
            out = b-a
        if out &gt; 180.0:
            out = 360.0-out
        return out

    # decimal to degrees (a°b&#39;c&#34;)
    def dec2deg(self, dec, type=&#34;3&#34;):
        dec = float(dec)
        a = int(dec)
        a_new = (dec-float(a)) * 60.0
        b_rounded = int(round(a_new))
        b = int(a_new)
        c = int(round((a_new-float(b))*60.0))
        if type == &#34;3&#34;:
            out = &#39;%(#1)02d&amp;#176;%(#2)02d&amp;#39;%(#3)02d&amp;#34;&#39; % {
                &#39;#1&#39;: a, &#39;#2&#39;: b, &#39;#3&#39;: c}
        elif type == &#34;2&#34;:
            out = &#39;%(#1)02d&amp;#176;%(#2)02d&amp;#39;&#39; % {&#39;#1&#39;: a, &#39;#2&#39;: b_rounded}
        elif type == &#34;1&#34;:
            out = &#39;%(#1)02d&amp;#176;&#39; % {&#39;#1&#39;: a}
        return str(out)

    # draw svg aspects: ring, aspect ring, degreeA degreeB
    def drawAspect(self, r, ar, degA, degB, color):
        offset = (int(self.houses_degree_ut[6]) / -1) + int(degA)
        x1 = self.sliceToX(0, ar, offset) + (r-ar)
        y1 = self.sliceToY(0, ar, offset) + (r-ar)
        offset = (int(self.houses_degree_ut[6]) / -1) + int(degB)
        x2 = self.sliceToX(0, ar, offset) + (r-ar)
        y2 = self.sliceToY(0, ar, offset) + (r-ar)
        out = &#39;            &lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
            y2)+&#39;&#34; style=&#34;stroke: &#39;+color+&#39;; stroke-width: 1; stroke-opacity: .9;&#34;/&gt;\n&#39;
        return out

    def sliceToX(self, slice, r, offset):
        plus = (math.pi * offset) / 180
        radial = ((math.pi/6) * slice) + plus
        return r * (math.cos(radial)+1)

    def sliceToY(self, slice, r, offset):
        plus = (math.pi * offset) / 180
        radial = ((math.pi/6) * slice) + plus
        return r * ((math.sin(radial)/-1)+1)

    def zodiacSlice(self, num, r, style,  type):
        # pie slices
        offset = 360 - self.houses_degree_ut[6]
        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 0
        else:
            dropin = self.c1
        slice = &#39;&lt;path d=&#34;M&#39; + str(r) + &#39;,&#39; + str(r) + &#39; L&#39; + str(dropin + self.sliceToX(num, r-dropin, offset)) + &#39;,&#39; + str(dropin + self.sliceToY(num, r-dropin, offset)) + &#39; A&#39; + str(
            r-dropin) + &#39;,&#39; + str(r-dropin) + &#39; 0 0,0 &#39; + str(dropin + self.sliceToX(num+1, r-dropin, offset)) + &#39;,&#39; + str(dropin + self.sliceToY(num+1, r-dropin, offset)) + &#39; z&#34; style=&#34;&#39; + style + &#39;&#34;/&gt;&#39;
        # symbols
        offset = offset + 15
        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 54
        else:
            dropin = 18+self.c1
        sign = &#39;&lt;g transform=&#34;translate(-16,-16)&#34;&gt;&lt;use x=&#34;&#39; + str(dropin + self.sliceToX(num, r-dropin, offset)) + &#39;&#34; y=&#34;&#39; + str(
            dropin + self.sliceToY(num, r-dropin, offset)) + &#39;&#34; xlink:href=&#34;#&#39; + type + &#39;&#34; /&gt;&lt;/g&gt;\n&#39;
        return slice + &#39;\n&#39; + sign

    def makeZodiac(self, r):
        output = &#34;&#34;
        for i in range(len(self.zodiac)):
            output = output + self.zodiacSlice(i, r, &#34;fill:&#34; + self.colors_settings[&#34;zodiac_bg_%s&#34; % (
                i)] + &#34;; fill-opacity: 0.5;&#34;, self.zodiac[i]) + &#39;\n&#39;
        return output

    def makeHouses(self, r):
        path = &#34;&#34;

        xr = 12
        for i in range(xr):
            # check transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 160
                roff = 72
                t_roff = 36
            else:
                dropin = self.c3
                roff = self.c1

            # offset is negative desc houses_degree_ut[6]
            offset = (
                int(self.houses_degree_ut[int(xr/2)]) / -1) + int(self.houses_degree_ut[i])
            x1 = self.sliceToX(0, (r-dropin), offset) + dropin
            y1 = self.sliceToY(0, (r-dropin), offset) + dropin
            x2 = self.sliceToX(0, r-roff, offset) + roff
            y2 = self.sliceToY(0, r-roff, offset) + roff

            if i &lt; (xr-1):
                text_offset = offset + \
                    int(self.degreeDiff(self.houses_degree_ut[(
                        i+1)], self.houses_degree_ut[i]) / 2)
            else:
                text_offset = offset + \
                    int(self.degreeDiff(
                        self.houses_degree_ut[0], self.houses_degree_ut[(xr-1)]) / 2)

            # mc, asc, dsc, ic
            if i == 0:
                linecolor = self.planets_settings[12][&#39;color&#39;]
            elif i == 9:
                linecolor = self.planets_settings[13][&#39;color&#39;]
            elif i == 6:
                linecolor = self.planets_settings[14][&#39;color&#39;]
            elif i == 3:
                linecolor = self.planets_settings[15][&#39;color&#39;]
            else:
                linecolor = self.colors_settings[&#39;houses_radix_line&#39;]

            # Transit houses lines.
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

                # Degrees for point zero.

                zeropoint = 360 - self.houses_degree_ut[6]
                t_offset = zeropoint + self.t_houses_degree_ut[i]
                if t_offset &gt; 360:
                    t_offset = t_offset - 360
                t_x1 = self.sliceToX(0, (r-t_roff), t_offset) + t_roff
                t_y1 = self.sliceToY(0, (r-t_roff), t_offset) + t_roff
                t_x2 = self.sliceToX(0, r, t_offset)
                t_y2 = self.sliceToY(0, r, t_offset)
                if i &lt; 11:
                    t_text_offset = t_offset + \
                        int(self.degreeDiff(self.t_houses_degree_ut[(
                            i+1)], self.t_houses_degree_ut[i]) / 2)
                else:
                    t_text_offset = t_offset + \
                        int(self.degreeDiff(
                            self.t_houses_degree_ut[0], self.t_houses_degree_ut[11]) / 2)
                # linecolor
                if i == 0 or i == 9 or i == 6 or i == 3:
                    t_linecolor = linecolor
                else:
                    t_linecolor = self.colors_settings[&#39;houses_transit_line&#39;]
                xtext = self.sliceToX(0, (r-8), t_text_offset) + 8
                ytext = self.sliceToY(0, (r-8), t_text_offset) + 8

                if self.type == &#34;Transit&#34;:
                    path = path + &#39;&lt;text style=&#34;fill: #00f; fill-opacity: 0; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                        str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                        &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;
                    path = path + &#39;&lt;line x1=&#34;&#39;+str(t_x1)+&#39;&#34; y1=&#34;&#39;+str(t_y1)+&#39;&#34; x2=&#34;&#39;+str(t_x2)+&#39;&#34; y2=&#34;&#39;+str(
                        t_y2)+&#39;&#34; style=&#34;stroke: &#39;+t_linecolor+&#39;; stroke-width: 2px; stroke-opacity:0;&#34;/&gt;\n&#39;

                else:
                    path = path + &#39;&lt;text style=&#34;fill: #00f; fill-opacity: .4; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                        str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                        &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;
                    path = path + &#39;&lt;line x1=&#34;&#39;+str(t_x1)+&#39;&#34; y1=&#34;&#39;+str(t_y1)+&#39;&#34; x2=&#34;&#39;+str(t_x2)+&#39;&#34; y2=&#34;&#39;+str(
                        t_y2)+&#39;&#34; style=&#34;stroke: &#39;+t_linecolor+&#39;; stroke-width: 2px; stroke-opacity:.3;&#34;/&gt;\n&#39;

            # if transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 84

            dropin = 48

            xtext = self.sliceToX(
                0, (r-dropin), text_offset) + dropin  # was 132
            ytext = self.sliceToY(
                0, (r-dropin), text_offset) + dropin  # was 132
            path = path + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+linecolor+&#39;; stroke-width: 2px; stroke-dasharray:3,2; stroke-opacity:.4;&#34;/&gt;\n&#39;
            path = path + &#39;&lt;text style=&#34;fill: #f00; fill-opacity: .6; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;

        return path

    def makePlanets(self, r):

        planets_degut = {}

        diff = range(len(self.planets_settings))
        for i in range(len(self.planets_settings)):
            if self.planets_settings[i][&#39;visible&#39;] == 1:
                # list of planets sorted by degree
                planets_degut[self.planets_degree_ut[i]] = i

            # element: get extra points if planet is in own zodiac
            pz = self.planets_settings[i][&#39;zodiac_relation&#39;]
            cz = self.planets_sign[i]
            extrapoints = 0
            if pz != -1:
                for e in range(len(pz.split(&#39;,&#39;))):
                    if int(pz.split(&#39;,&#39;)[e]) == int(cz):
                        extrapoints = 10

            # calculate element points for all planets
            ele = self.zodiac_element[self.planets_sign[i]]
            if ele == &#34;fire&#34;:
                self.fire = self.fire + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints
            elif ele == &#34;earth&#34;:
                self.earth = self.earth + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints
            elif ele == &#34;air&#34;:
                self.air = self.air + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints
            elif ele == &#34;water&#34;:
                self.water = self.water + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints

        output = &#34;&#34;
        keys = list(planets_degut.keys())
        keys.sort()
        switch = 0

        planets_degrouped = {}
        groups = []
        planets_by_pos = list(range(len(planets_degut)))
        planet_drange = 3.4
        # get groups closely together
        group_open = False
        for e in range(len(keys)):
            i = planets_degut[keys[e]]
            # get distances between planets
            if e == 0:
                prev = self.planets_degree_ut[planets_degut[keys[-1]]]
                next = self.planets_degree_ut[planets_degut[keys[1]]]
            elif e == (len(keys)-1):
                prev = self.planets_degree_ut[planets_degut[keys[e-1]]]
                next = self.planets_degree_ut[planets_degut[keys[0]]]
            else:
                prev = self.planets_degree_ut[planets_degut[keys[e-1]]]
                next = self.planets_degree_ut[planets_degut[keys[e+1]]]
            diffa = self.degreeDiff(prev, self.planets_degree_ut[i])
            diffb = self.degreeDiff(next, self.planets_degree_ut[i])
            planets_by_pos[e] = [i, diffa, diffb]
            # print &#34;%s %s %s&#34; % (self.planets_settings[i][&#39;label&#39;],diffa,diffb)
            if (diffb &lt; planet_drange):
                if group_open:
                    groups[-1].append([e, diffa, diffb,
                                      self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
                else:
                    group_open = True
                    groups.append([])
                    groups[-1].append([e, diffa, diffb,
                                      self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
            else:
                if group_open:
                    groups[-1].append([e, diffa, diffb,
                                      self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
                group_open = False

        def zero(x): return 0
        planets_delta = list(map(zero, range(len(self.planets_settings))))

        # print groups
        # print planets_by_pos
        for a in range(len(groups)):
            # Two grouped planets
            if len(groups[a]) == 2:
                next_to_a = groups[a][0][0]-1
                if groups[a][1][0] == (len(planets_by_pos)-1):
                    next_to_b = 0
                else:
                    next_to_b = groups[a][1][0]+1
                # if both planets have room
                if (groups[a][0][1] &gt; (2*planet_drange)) &amp; (groups[a][1][2] &gt; (2*planet_drange)):
                    planets_delta[groups[a][0][0]] = - \
                        (planet_drange-groups[a][0][2])/2
                    planets_delta[groups[a][1][0]] = + \
                        (planet_drange-groups[a][0][2])/2
                # if planet a has room
                elif (groups[a][0][1] &gt; (2*planet_drange)):
                    planets_delta[groups[a][0][0]] = -planet_drange
                # if planet b has room
                elif (groups[a][1][2] &gt; (2*planet_drange)):
                    planets_delta[groups[a][1][0]] = +planet_drange

                # if planets next to a and b have room move them
                elif (planets_by_pos[next_to_a][1] &gt; (2.4*planet_drange)) &amp; (planets_by_pos[next_to_b][2] &gt; (2.4*planet_drange)):
                    planets_delta[(next_to_a)] = (
                        groups[a][0][1]-planet_drange*2)
                    planets_delta[groups[a][0][0]] = -planet_drange*.5
                    planets_delta[next_to_b] = - \
                        (groups[a][1][2]-planet_drange*2)
                    planets_delta[groups[a][1][0]] = +planet_drange*.5

                # if planet next to a has room move them
                elif (planets_by_pos[next_to_a][1] &gt; (2*planet_drange)):
                    planets_delta[(next_to_a)] = (
                        groups[a][0][1]-planet_drange*2.5)
                    planets_delta[groups[a][0][0]] = -planet_drange*1.2

                # if planet next to b has room move them
                elif (planets_by_pos[next_to_b][2] &gt; (2*planet_drange)):
                    planets_delta[next_to_b] = - \
                        (groups[a][1][2]-planet_drange*2.5)
                    planets_delta[groups[a][1][0]] = +planet_drange*1.2

            # Three grouped planets or more
            xl = len(groups[a])
            if xl &gt;= 3:

                available = groups[a][0][1]
                for f in range(xl):
                    available += groups[a][f][2]
                need = (3*planet_drange)+(1.2*(xl-1)*planet_drange)
                leftover = available - need
                xa = groups[a][0][1]
                xb = groups[a][(xl-1)][2]

                # center
                if (xa &gt; (need*.5)) &amp; (xb &gt; (need*.5)):
                    startA = xa - (need*.5)
                # position relative to next planets
                else:
                    startA = (leftover/(xa+xb))*xa
                    startB = (leftover/(xa+xb))*xb

                if available &gt; need:
                    planets_delta[groups[a][0][0]] = startA - \
                        groups[a][0][1]+(1.5*planet_drange)
                    for f in range(xl-1):
                        planets_delta[groups[a][(
                            f+1)][0]] = 1.2*planet_drange+planets_delta[groups[a][f][0]]-groups[a][f][2]

        for e in range(len(keys)):
            i = planets_degut[keys[e]]

            # coordinates
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                if 22 &lt; i &lt; 27:
                    rplanet = 76
                elif switch == 1:
                    rplanet = 110
                    switch = 0
                else:
                    rplanet = 130
                    switch = 1
            else:
                # if 22 &lt; i &lt; 27 it is asc,mc,dsc,ic (angles of chart)
                # put on special line (rplanet is range from outer ring)
                amin, bmin, cmin = 0, 0, 0

                if 22 &lt; i &lt; 27:
                    rplanet = 40-cmin
                elif switch == 1:
                    rplanet = 74-amin
                    switch = 0
                else:
                    rplanet = 94-bmin
                    switch = 1

            rtext = 45

            offset = (int(self.houses_degree_ut[6]) / -1) + \
                int(self.planets_degree_ut[i]+planets_delta[e])
            trueoffset = (
                int(self.houses_degree_ut[6]) / -1) + int(self.planets_degree_ut[i])

            planet_x = self.sliceToX(0, (r-rplanet), offset) + rplanet
            planet_y = self.sliceToY(0, (r-rplanet), offset) + rplanet
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                scale = 0.8

            scale = 1
            # output planet
            output = output + &#39;&lt;g transform=&#34;translate(-&#39;+str(12*scale)+&#39;,-&#39;+str(12*scale)+&#39;)&#34;&gt;&lt;g transform=&#34;scale(&#39;+str(scale)+&#39;)&#34;&gt;&lt;use x=&#34;&#39; + str(
                planet_x*(1/scale)) + &#39;&#34; y=&#34;&#39; + str(planet_y*(1/scale)) + &#39;&#34; xlink:href=&#34;#&#39; + self.planets_settings[i][&#39;name&#39;] + &#39;&#34; /&gt;&lt;/g&gt;&lt;/g&gt;\n&#39;

        # make transit degut and display planets
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            group_offset = {}
            t_planets_degut = {}
            if self.type == &#34;Transit&#34;:
                list_range = len(self.planets_settings)-4
            else:
                list_range = len(self.planets_settings)
            for i in range(list_range):
                group_offset[i] = 0
                if self.planets_settings[i][&#39;visible&#39;] == 1:
                    t_planets_degut[self.t_planets_degree_ut[i]] = i
            t_keys = list(t_planets_degut.keys())
            t_keys.sort()

            # grab closely grouped planets
            groups = []
            in_group = False
            for e in range(len(t_keys)):
                i_a = t_planets_degut[t_keys[e]]
                if e == (len(t_keys)-1):
                    i_b = t_planets_degut[t_keys[0]]
                else:
                    i_b = t_planets_degut[t_keys[e+1]]

                a = self.t_planets_degree_ut[i_a]
                b = self.t_planets_degree_ut[i_b]
                diff = self.degreeDiff(a, b)
                if diff &lt;= 2.5:
                    if in_group:
                        groups[-1].append(i_b)
                    else:
                        groups.append([i_a])
                        groups[-1].append(i_b)
                        in_group = True
                else:
                    in_group = False
            # loop groups and set degrees display adjustment
            for i in range(len(groups)):
                if len(groups[i]) == 2:
                    group_offset[groups[i][0]] = -1.0
                    group_offset[groups[i][1]] = 1.0
                elif len(groups[i]) == 3:
                    group_offset[groups[i][0]] = -1.5
                    group_offset[groups[i][1]] = 0
                    group_offset[groups[i][2]] = 1.5
                elif len(groups[i]) == 4:
                    group_offset[groups[i][0]] = -2.0
                    group_offset[groups[i][1]] = -1.0
                    group_offset[groups[i][2]] = 1.0
                    group_offset[groups[i][3]] = 2.0

            switch = 0
            for e in range(len(t_keys)):
                i = t_planets_degut[t_keys[e]]

                if 22 &lt; i &lt; 27:
                    rplanet = 9
                elif switch == 1:
                    rplanet = 18
                    switch = 0
                else:
                    rplanet = 26
                    switch = 1

                zeropoint = 360 - self.houses_degree_ut[6]
                t_offset = zeropoint + self.t_planets_degree_ut[i]
                if t_offset &gt; 360:
                    t_offset = t_offset - 360
                planet_x = self.sliceToX(0, (r-rplanet), t_offset) + rplanet
                planet_y = self.sliceToY(0, (r-rplanet), t_offset) + rplanet
                output = output + &#39;&lt;g transform=&#34;translate(-6,-6)&#34;&gt;&lt;g transform=&#34;scale(0.5)&#34;&gt;&lt;use x=&#34;&#39; + str(
                    planet_x*2) + &#39;&#34; y=&#34;&#39; + str(planet_y*2) + &#39;&#34; xlink:href=&#34;#&#39; + self.planets_settings[i][&#39;name&#39;] + &#39;&#34; /&gt;&lt;/g&gt;&lt;/g&gt;\n&#39;
                # transit planet line
                x1 = self.sliceToX(0, r+3, t_offset) - 3
                y1 = self.sliceToY(0, r+3, t_offset) - 3
                x2 = self.sliceToX(0, r-3, t_offset) + 3
                y2 = self.sliceToY(0, r-3, t_offset) + 3
                output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                    y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 1px; stroke-opacity:.8;&#34;/&gt;\n&#39;

                # transit planet degree text
                rotate = self.houses_degree_ut[0] - self.t_planets_degree_ut[i]
                textanchor = &#34;end&#34;
                t_offset += group_offset[i]
                rtext = -3.0

                if -90 &gt; rotate &gt; -270:
                    rotate = rotate + 180.0
                    textanchor = &#34;start&#34;
                if 270 &gt; rotate &gt; 90:
                    rotate = rotate - 180.0
                    textanchor = &#34;start&#34;

                if textanchor == &#34;end&#34;:
                    xo = 1
                else:
                    xo = -1
                deg_x = self.sliceToX(0, (r-rtext), t_offset + xo) + rtext
                deg_y = self.sliceToY(0, (r-rtext), t_offset + xo) + rtext
                degree = int(t_offset)
                output += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (deg_x, deg_y)
                output += &#39;&lt;text transform=&#34;rotate(%s)&#34; text-anchor=&#34;%s&#39; % (
                    rotate, textanchor)
                output += &#39;&#34; style=&#34;fill: &#39; + \
                    self.planets_settings[i][&#39;color&#39;]+&#39;; font-size: 10px;&#34;&gt;&#39; + \
                    self.dec2deg(self.t_planets_degree[i], type=&#34;1&#34;)
                output += &#39;&lt;/text&gt;&lt;/g&gt;\n&#39;

            # check transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 36
            else:
                dropin = 0

            # planet line
            x1 = self.sliceToX(0, r-(dropin+3), offset) + (dropin+3)
            y1 = self.sliceToY(0, r-(dropin+3), offset) + (dropin+3)
            x2 = self.sliceToX(0, (r-(dropin-3)), offset) + (dropin-3)
            y2 = self.sliceToY(0, (r-(dropin-3)), offset) + (dropin-3)
            output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 2px; stroke-opacity:.6;&#34;/&gt;\n&#39;

            # check transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 160
            else:
                dropin = 120

            x1 = self.sliceToX(0, r-dropin, offset) + dropin
            y1 = self.sliceToY(0, r-dropin, offset) + dropin
            x2 = self.sliceToX(0, (r-(dropin-3)), offset) + (dropin-3)
            y2 = self.sliceToY(0, (r-(dropin-3)), offset) + (dropin-3)
            output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 2px; stroke-opacity:.6;&#34;/&gt;\n&#39;

        return output

    def makePatterns(self):
        &#34;&#34;&#34;
        * Stellium: At least four planets linked together in a series of continuous conjunctions.
        * Grand trine: Three trine aspects together.
        * Grand cross: Two pairs of opposing planets squared to each other.
        * T-Square: Two planets in opposition squared to a third.
        * Yod: Two qunicunxes together joined by a sextile.
        &#34;&#34;&#34;
        conj = {}  # 0
        opp = {}  # 10
        sq = {}  # 5
        tr = {}  # 6
        qc = {}  # 9
        sext = {}  # 3
        for i in range(len(self.planets_settings)):
            a = self.planets_degree_ut[i]
            qc[i] = {}
            sext[i] = {}
            opp[i] = {}
            sq[i] = {}
            tr[i] = {}
            conj[i] = {}
            # skip some points
            n = self.planets_settings[i][&#39;name&#39;]
            if n == &#39;earth&#39; or n == &#39;True_Node&#39; or n == &#39;osc. apogee&#39; or n == &#39;intp. apogee&#39; or n == &#39;intp. perigee&#39;:
                continue
            if n == &#39;Dsc&#39; or n == &#39;Ic&#39;:
                continue
            for j in range(len(self.planets_settings)):
                # skip some points
                n = self.planets_settings[j][&#39;name&#39;]
                if n == &#39;earth&#39; or n == &#39;True_Node&#39; or n == &#39;osc. apogee&#39; or n == &#39;intp. apogee&#39; or n == &#39;intp. perigee&#39;:
                    continue
                if n == &#39;Dsc&#39; or n == &#39;Ic&#39;:
                    continue
                b = self.planets_degree_ut[j]
                delta = float(self.degreeDiff(a, b))
                # check for opposition
                xa = float(self.aspects_settings[10][&#39;degree&#39;]) - \
                    float(self.aspects_settings[10][&#39;orb&#39;])
                xb = float(self.aspects_settings[10][&#39;degree&#39;]) + \
                    float(self.aspects_settings[10][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    opp[i][j] = True
                # check for conjunction
                xa = float(self.aspects_settings[0][&#39;degree&#39;]) - \
                    float(self.aspects_settings[0][&#39;orb&#39;])
                xb = float(self.aspects_settings[0][&#39;degree&#39;]) + \
                    float(self.aspects_settings[0][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    conj[i][j] = True
                # check for squares
                xa = float(self.aspects_settings[5][&#39;degree&#39;]) - \
                    float(self.aspects_settings[5][&#39;orb&#39;])
                xb = float(self.aspects_settings[5][&#39;degree&#39;]) + \
                    float(self.aspects_settings[5][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    sq[i][j] = True
                # check for qunicunxes
                xa = float(self.aspects_settings[9][&#39;degree&#39;]) - \
                    float(self.aspects_settings[9][&#39;orb&#39;])
                xb = float(self.aspects_settings[9][&#39;degree&#39;]) + \
                    float(self.aspects_settings[9][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    qc[i][j] = True
                # check for sextiles
                xa = float(self.aspects_settings[3][&#39;degree&#39;]) - \
                    float(self.aspects_settings[3][&#39;orb&#39;])
                xb = float(self.aspects_settings[3][&#39;degree&#39;]) + \
                    float(self.aspects_settings[3][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    sext[i][j] = True

        yot = {}
        # check for double qunicunxes
        for k, v in qc.items():
            if len(qc[k]) &gt;= 2:
                # check for sextile
                for l, w in qc[k].items():
                    for m, x in qc[k].items():
                        if m in sext[l]:
                            if l &gt; m:
                                yot[&#39;%s,%s,%s&#39; % (k, m, l)] = [k, m, l]
                            else:
                                yot[&#39;%s,%s,%s&#39; % (k, l, m)] = [k, l, m]
        tsquare = {}
        # check for opposition
        for k, v in opp.items():
            if len(opp[k]) &gt;= 1:
                # check for square
                for l, w in opp[k].items():
                    for a, b in sq.items():
                        if k in sq[a] and l in sq[a]:
                            # print &#39;got tsquare %s %s %s&#39; % (a,k,l)
                            if k &gt; l:
                                tsquare[&#39;%s,%s,%s&#39; % (a, l, k)] = &#39;%s =&gt; %s, %s&#39; % (
                                    self.planets_settings[a][&#39;label&#39;], self.planets_settings[l][&#39;label&#39;], self.planets_settings[k][&#39;label&#39;])
                            else:
                                tsquare[&#39;%s,%s,%s&#39; % (a, k, l)] = &#39;%s =&gt; %s, %s&#39; % (
                                    self.planets_settings[a][&#39;label&#39;], self.planets_settings[k][&#39;label&#39;], self.planets_settings[l][&#39;label&#39;])
        stellium = {}
        # check for 4 continuous conjunctions
        for k, v in conj.items():
            if len(conj[k]) &gt;= 1:
                # first conjunction
                for l, m in conj[k].items():
                    if len(conj[l]) &gt;= 1:
                        for n, o in conj[l].items():
                            # skip 1st conj
                            if n == k:
                                continue
                            if len(conj[n]) &gt;= 1:
                                # third conjunction
                                for p, q in conj[n].items():
                                    # skip first and second conj
                                    if p == k or p == n:
                                        continue
                                    if len(conj[p]) &gt;= 1:
                                        # fourth conjunction
                                        for r, s in conj[p].items():
                                            # skip conj 1,2,3
                                            if r == k or r == n or r == p:
                                                continue

                                            l = [k, n, p, r]
                                            l.sort()
                                            stellium[&#39;%s %s %s %s&#39; % (l[0], l[1], l[2], l[3])] = &#39;%s %s %s %s&#39; % (
                                                self.planets_settings[l[0]
                                                                      ][&#39;label&#39;], self.planets_settings[l[1]][&#39;label&#39;],
                                                self.planets_settings[l[2]][&#39;label&#39;], self.planets_settings[l[3]][&#39;label&#39;])
        # print yots
        out = &#39;&lt;g transform=&#34;translate(-30,380)&#34;&gt;&#39;
        if len(yot) &gt;= 1:
            y = 0
            for k, v in yot.items():
                out += &#39;&lt;text y=&#34;%s&#34; style=&#34;fill:%s; font-size: 12px;&#34;&gt;%s&lt;/text&gt;\n&#39; % (
                    y, self.colors_settings[&#39;paper_0&#39;], (&#34;Yot&#34;))

                # first planet symbol
                out += &#39;&lt;g transform=&#34;translate(20,%s)&#34;&gt;&#39; % (y)
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                    self.planets_settings[yot[k][0]][&#39;name&#39;])

                # second planet symbol
                out += &#39;&lt;g transform=&#34;translate(30,%s)&#34;&gt;&#39; % (y)
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                    self.planets_settings[yot[k][1]][&#39;name&#39;])

                # third planet symbol
                out += &#39;&lt;g transform=&#34;translate(40,%s)&#34;&gt;&#39; % (y)
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                    self.planets_settings[yot[k][2]][&#39;name&#39;])

                y = y+14
        # finalize
        out += &#39;&lt;/g&gt;&#39;
        # return out
        return &#39;&#39;

    # Aspect and aspect grid functions for natal type charts.

    def makeAspects(self, r, ar):
        out = &#34;&#34;
        for element in self.aspects_list:
            out += self.drawAspect(r, ar, element[&#39;p1_abs_pos&#39;], element[&#39;p2_abs_pos&#39;],
                                   self.colors_settings[f&#34;aspect_{element[&#39;aspect_degrees&#39;]}&#34;])

        return out

    def makeAspectGrid(self, r):

        out = &#34;&#34;
        style = &#39;stroke:%s; stroke-width: 1px; stroke-opacity:.6; fill:none&#39; % (
            self.colors_settings[&#39;paper_0&#39;])
        xindent = 380
        yindent = 468
        box = 14
        revr = list(range(len(self.planets_settings)))
        revr.reverse()
        counter = 0
        for a in revr:
            counter += 1
            if self.planets_settings[a][&#39;visible&#39;] == 1:
                out += &#39;&lt;rect x=&#34;&#39;+str(xindent)+&#39;&#34; y=&#34;&#39;+str(yindent)+&#39;&#34; width=&#34;&#39;+str(
                    box)+&#39;&#34; height=&#34;&#39;+str(box)+&#39;&#34; style=&#34;&#39;+style+&#39;&#34;/&gt;\n&#39;
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;&#39;+str((xindent+2)*2.5)+&#39;&#34; y=&#34;&#39;+str(
                    (yindent+1)*2.5)+&#39;&#34; xlink:href=&#34;#&#39;+self.planets_settings[a][&#39;name&#39;]+&#39;&#34; /&gt;\n&#39;
                xindent = xindent + box
                yindent = yindent - box
                revr2 = list(range(a))
                revr2.reverse()
                xorb = xindent
                yorb = yindent + box
                for b in revr2:
                    if self.planets_settings[b][&#39;visible&#39;] == 1:
                        out += &#39;&lt;rect x=&#34;&#39;+str(xorb)+&#39;&#34; y=&#34;&#39;+str(yorb)+&#39;&#34; width=&#34;&#39;+str(
                            box)+&#39;&#34; height=&#34;&#39;+str(box)+&#39;&#34; style=&#34;&#39;+style+&#39;&#34;/&gt;\n&#39;
                        xorb = xorb+box
                        for element in self.aspects_list:
                            if (element[&#39;p1&#39;] == a and element[&#39;p2&#39;] == b) or (element[&#39;p1&#39;] == b and element[&#39;p2&#39;] == a):
                                out += &#39;&lt;use  x=&#34;&#39;+str(xorb-box+1)+&#39;&#34; y=&#34;&#39;+str(
                                    yorb+1)+&#39;&#34; xlink:href=&#34;#orb&#39;+str(element[&#39;aspect_degrees&#39;])+&#39;&#34; /&gt;\n&#39;

        return out

    # Aspect and aspect grid functions for transit type charts.

    def makeAspectsTransit(self, r, ar):
        out = &#34;&#34;

        self.aspects_list = kr.utilities.CompositeAspects(
            self.user, self.t_user, new_settings_file=self.settings_file
            ).get_aspects()

        for element in self.aspects_list:
            out += self.drawAspect(r, ar, element[&#39;p1_abs_pos&#39;], element[&#39;p2_abs_pos&#39;],
                                   self.colors_settings[f&#34;aspect_{element[&#39;aspect_degrees&#39;]}&#34;])

        return out

    def makeAspectTransitGrid(self, r):
        out = &#39;&lt;g transform=&#34;translate(500,310)&#34;&gt;&#39;
        out += &#39;&lt;text y=&#34;-15&#34; x=&#34;0&#34; style=&#34;fill:%s; font-size: 14px;&#34;&gt;%s&lt;/text&gt;\n&#39; % (
            self.colors_settings[&#39;paper_0&#39;], (f&#34;{self.language_settings[&#39;aspects&#39;]}:&#34;))
        line = 0
        nl = 0
        for i in range(len(self.aspects_list)):
            if i == 12:
                nl = 100
                # if len(self.aspects_list) &gt; 24:
                #     line = -1 * ( len(self.aspects_list) - 24) * 14
                # else:
                #     line = 0

                # temporary:
                line = 0

            if i == 24:
                nl = 200
                # if len(self.aspects_list) &gt; 36:
                #     line = -1 * ( len(self.aspects_list) - 36) * 14
                # else:
                #     line = 0
                line = 0

            if i == 36:
                nl = 300
                if len(self.aspects_list) &gt; 48:
                    line = -1 * (len(self.aspects_list) - 48) * 14
                else:
                    line = 0
            out += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (nl, line)
            # first planet symbol
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;3&#34; xlink:href=&#34;#%s&#34; /&gt;\n&#39; % (
                self.planets_settings[self.aspects_list[i][&#39;p1&#39;]][&#39;name&#39;])
            # aspect symbol
            out += &#39;&lt;use  x=&#34;15&#34; y=&#34;0&#34; xlink:href=&#34;#orb%s&#34; /&gt;\n&#39; % (
                self.aspects_settings[self.aspects_list[i][&#39;aid&#39;]][&#39;degree&#39;])
            # second planet symbol
            out += &#39;&lt;g transform=&#34;translate(30,0)&#34;&gt;&#39;
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;3&#34; xlink:href=&#34;#%s&#34; /&gt;\n&#39; % (
                self.planets_settings[self.aspects_list[i][&#39;p2&#39;]][&#39;name&#39;])
            out += &#39;&lt;/g&gt;&#39;
            # difference in degrees
            out += &#39;&lt;text y=&#34;8&#34; x=&#34;45&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;],
                self.dec2deg(self.aspects_list[i][&#39;orbit&#39;]))
            # line
            out += &#39;&lt;/g&gt;&#39;
            line = line + 14
        out += &#39;&lt;/g&gt;&#39;
        return out

    def makeElements(self, r):
        total = self.fire + self.earth + self.air + self.water
        pf = int(round(100*self.fire/total))
        pe = int(round(100*self.earth/total))
        pa = int(round(100*self.air/total))
        pw = int(round(100*self.water/total))
        out = &#39;&lt;g transform=&#34;translate(-30,79)&#34;&gt;\n&#39;
        out += &#39;&lt;text y=&#34;0&#34; style=&#34;fill:#ff6600; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;fire&#39;]+&#39;  &#39;+str(pf)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;text y=&#34;12&#34; style=&#34;fill:#6a2d04; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;earth&#39;]+&#39; &#39;+str(pe)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;text y=&#34;24&#34; style=&#34;fill:#6f76d1; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;air&#39;]+&#39;   &#39;+str(pa)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;text y=&#34;36&#34; style=&#34;fill:#630e73; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;water&#39;]+&#39; &#39;+str(pw)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;/g&gt;\n&#39;
        return out

    def makePlanetGrid(self):
        out = &#39;&lt;g transform=&#34;translate(500,-20)&#34;&gt;&#39;

        # loop over all planets
        li = 10
        offset = 0

        out += &#39;&lt;g transform=&#34;translate(140, -15)&#34;&gt;&#39;
        out += \
            f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.language_settings[&#34;planets_and_house&#34;]} {self.name}:&lt;/text&gt;&#39;
        out += &#39;&lt;/g&gt;\n&#39;

        for i in range(len(self.planets_settings)):

            # Guarda qui !!
            if i == 27:
                li = 10
                offset = -120
            if self.planets_settings[i][&#39;visible&#39;] == 1:
                # start of line
                out += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (offset, li)
                # planet text
                out += f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 10px;&#34;&gt;{self.language_settings[&#34;planets&#34;][self.planets_settings[i][&#34;label&#34;]]}&lt;/text&gt;&#39;
                # planet symbol
                out += \
                    &#39;&lt;g transform=&#34;translate(5,-8)&#34;&gt;&lt;use transform=&#34;scale(0.4)&#34; xlink:href=&#34;#&#39; + \
                    self.planets_settings[i][&#39;name&#39;]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                # planet degree
                out += &#39;&lt;text text-anchor=&#34;start&#34; x=&#34;19&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.planets_degree[i]))
                # zodiac
                out += &#39;&lt;g transform=&#34;translate(60,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                    self.zodiac[self.planets_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                # planet retrograde
                if self.planets_retrograde[i]:
                    out += \
                        &#39;&lt;g transform=&#34;translate(74,-6)&#34;&gt;&lt;use transform=&#34;scale(.5)&#34; xlink:href=&#34;#retrograde&#34; /&gt;&lt;/g&gt;&#39;

                # end of line
                out += &#39;&lt;/g&gt;\n&#39;
                # offset between lines
                li = li + 14

        # ----------

        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

            if self.type == &#34;Transit&#34;:
                out += &#39;&lt;g transform=&#34;translate(320, -15)&#34;&gt;&#39;
                out += \
                    f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.t_name}:&lt;/text&gt;&#39;
            else:
                out += &#39;&lt;g transform=&#34;translate(380, -15)&#34;&gt;&#39;
                out += \
                    f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.language_settings[&#34;planets_and_house&#34;]} {self.t_user.name}:&lt;/text&gt;&#39;
            out += &#39;&lt;/g&gt;\n&#39;

            t_li = 10
            t_offset = 250

            for i in range(len(self.planets_settings)):
                if i == 27:
                    t_li = 10
                    t_offset = -120
                if self.planets_settings[i][&#39;visible&#39;] == 1:
                    # start of line
                    out += f&#39;&lt;g transform=&#34;translate({t_offset},{t_li})&#34;&gt;&#39;

                    # planet text
                    out += f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 10px;&#34;&gt;{self.language_settings[&#34;planets&#34;][self.planets_settings[i][&#34;label&#34;]]}&lt;/text&gt;&#39;
                    # planet symbol
                    out += f&#39;&lt;g transform=&#34;translate(5,-8)&#34;&gt;&lt;use transform=&#34;scale(0.4)&#34; xlink:href=&#34;# {self.planets_settings[i][&#34;name&#34;]}&#34; /&gt;&lt;/g&gt;&#39;
                    # planet degree
                    out += &#39;&lt;text text-anchor=&#34;start&#34; x=&#34;19&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                        self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.t_planets_degree[i]))
                    # zodiac
                    out += &#39;&lt;g transform=&#34;translate(60,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                        self.zodiac[self.t_planets_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                    # planet retrograde
                    if self.t_planets_retrograde[i]:
                        out += \
                            &#39;&lt;g transform=&#34;translate(74,-6)&#34;&gt;&lt;use transform=&#34;scale(.5)&#34; xlink:href=&#34;#retrograde&#34; /&gt;&lt;/g&gt;&#39;

                    # end of line
                    out += &#39;&lt;/g&gt;\n&#39;
                    # offset between lines
                    t_li = t_li + 14
        out += &#39;&lt;/g&gt;\n&#39;

        return out

    def makeHousesGrid(self):

        out = &#39;&lt;g transform=&#34;translate(600,-20)&#34;&gt;&#39;
        li = 10
        for i in range(12):
            if i &lt; 9:
                cusp = &#39;&amp;#160;&amp;#160;&#39;+str(i+1)
            else:
                cusp = str(i+1)
            out += &#39;&lt;g transform=&#34;translate(0,&#39;+str(li)+&#39;)&#34;&gt;&#39;
            out += &#39;&lt;text text-anchor=&#34;end&#34; x=&#34;40&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s %s:&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.language_settings[&#39;cusp&#39;], cusp)
            out += &#39;&lt;g transform=&#34;translate(40,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                self.zodiac[self.houses_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
            out += &#39;&lt;text x=&#34;53&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt; %s&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.houses_list[i][&#34;position&#34;]))
            out += &#39;&lt;/g&gt;\n&#39;
            li = li + 14
        out += &#39;&lt;/g&gt;\n&#39;

        # ----------

        if self.type == &#34;Composite&#34;:
            out += &#39;&lt;g transform=&#34;translate(840, -20)&#34;&gt;&#39;
            li = 10
            for i in range(12):
                if i &lt; 9:
                    cusp = &#39;&amp;#160;&amp;#160;&#39;+str(i+1)
                else:
                    cusp = str(i+1)
                out += &#39;&lt;g transform=&#34;translate(0,&#39;+str(li)+&#39;)&#34;&gt;&#39;
                out += &#39;&lt;text text-anchor=&#34;end&#34; x=&#34;40&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s %s:&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.language_settings[&#39;cusp&#39;], cusp)
                out += &#39;&lt;g transform=&#34;translate(40,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                    self.zodiac[self.t_houses_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                out += &#39;&lt;text x=&#34;53&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt; %s&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.t_houses_list[i][&#34;position&#34;]))
                out += &#39;&lt;/g&gt;\n&#39;
                li = li + 14
            out += &#39;&lt;/g&gt;\n&#39;

        return out

    def set_output_directory(self, dir_path):
        &#34;&#34;&#34;
        Sets the output direcotry and returns it&#39;s path.
        &#34;&#34;&#34;
        self.output_directory = Path(dir_path)
        dir_string = f&#34;Output direcotry set to: {self.output_directory}&#34;
        return (print(dir_string))


if __name__ == &#34;__main__&#34;:

    first = kr.KrInstance(&#34;Jack&#34;, 1990, 6, 15, 15, 15, &#34;Roma&#34;)
    second = kr.KrInstance(&#34;Jane&#34;, 1991, 10, 25, 21, 00, &#34;Roma&#34;)

    name = MakeSvgInstance(first, chart_type=&#34;Composite&#34;,
                           second_obj=second, lang=&#34;IT&#34;)
    # name.output_directory = Path.home() / &#34;charts&#34;
    template = name.makeTemplate()
    name.makeSVG()
    # print(len(name.aspects_list))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance"><code class="flex name class">
<span>class <span class="ident">MakeSvgInstance</span></span>
<span>(</span><span>first_obj: <a title="kerykeion.main.KrInstance" href="../../main.html#kerykeion.main.KrInstance">KrInstance</a>, chart_type: str = 'Natal', second_obj: Optional[<a title="kerykeion.main.KrInstance" href="../../main.html#kerykeion.main.KrInstance">KrInstance</a>] = None, new_output_directory: Optional[str] = None, template_type: str = 'extended', lang: str = 'EN', new_settings_file: Union[str, pathlib.Path, ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the instance that can genearte the chart with the
function makeSVG().</p>
<p>There are 2 templates, the extended (default) which has all the
information and the basic, which has just the chart.</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li>first_obj: First kerykeion object</li>
<li>chart_type: Natal, Transit, Composite (Default: Type="Natal")</li>
<li>second_obj: Second kerykeion object (Not required if type is Natal)</li>
<li>new_output_directory: Set the output directory (default: output_directory)</li>
<li>template_type: set the template type to include or not the aspects grid, default: extended)</li>
<li>lang: language settings (default: "EN")</li>
<li>new_settings_file: Set the settings file (default: kr.config.json)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MakeSvgInstance:
    &#34;&#34;&#34;
    Creates the instance that can genearte the chart with the
    function makeSVG().

    There are 2 templates, the extended (default) which has all the
    information and the basic, which has just the chart.

    Parameters:
        - first_obj: First kerykeion object
        - chart_type: Natal, Transit, Composite (Default: Type=&#34;Natal&#34;)
        - second_obj: Second kerykeion object (Not required if type is Natal)
        - new_output_directory: Set the output directory (default: output_directory)
        - template_type: set the template type to include or not the aspects grid, default: extended)
        - lang: language settings (default: &#34;EN&#34;)
        - new_settings_file: Set the settings file (default: kr.config.json)
    &#34;&#34;&#34;

    def __init__(
            self,
            first_obj: kr.KrInstance,
            chart_type: str = &#34;Natal&#34;,
            second_obj: Union[kr.KrInstance, None] = None,
            new_output_directory: Union[str, None] = None,
            template_type: str = &#34;extended&#34;,
            lang: str = &#34;EN&#34;,
            new_settings_file: Union[str, Path, None] = None,
    ):

        # Directories:
        DATADIR = Path(__file__).parent
        self.homedir = Path.home()
    

        if new_output_directory:
            self.output_directory = Path(new_output_directory)
        else:
            self.output_directory = self.homedir

        # Template types:
        if template_type == &#34;basic&#34;:
            self.xml_svg = DATADIR / &#39;templates/basic.xml&#39;
        else:
            self.xml_svg = DATADIR / &#39;templates/extended.xml&#39;

        # SVG Width
        self.natal_width = 772.2
        self.full_width = 1200

        # Settings file:
        if not new_settings_file:
            self.settings_file = DATADIR.parent / &#39;kr.config.json&#39;
        else:
            self.settings_file = Path(new_settings_file)
            

        self.parse_json_settings(self.settings_file, lang)
        self.type = chart_type

        # Kerykeion instance
        self.user = first_obj
        if not hasattr(self.user, &#34;sun&#34;):
            print(f&#34;Generating kerykeion object for {self.user.name}...&#34;)
            self.user.get_all()

        # Make a list for the absolute degrees of the points of the graphic.

        self.points_deg_ut = self.user.planets_degrees + [self.user.houses_degree_ut[0],
                                                          self.user.houses_degree_ut[9], self.user.houses_degree_ut[6],
                                                          self.user.houses_degree_ut[3]]

        # Make a list of the relative degrees of the points in the graphic.

        self.points_deg = []
        for planet in self.user.planets_list:
            self.points_deg.append(planet[&#34;position&#34;])

        self.points_deg = self.points_deg + [self.user.houses_list[0][&#34;position&#34;],
                                             self.user.houses_list[9][&#34;position&#34;], self.user.houses_list[6][&#34;position&#34;],
                                             self.user.houses_list[3][&#34;position&#34;]]

        # Make list of the poits sign.

        self.points_sign = []

        for planet in self.user.planets_list:
            self.points_sign.append(planet[&#34;sign_num&#34;])

        self.points_sign = self.points_sign + [self.user.houses_list[0][&#34;sign_num&#34;],
                                               self.user.houses_list[9][&#34;sign_num&#34;], self.user.houses_list[6][&#34;sign_num&#34;],
                                               self.user.houses_list[3][&#34;sign_num&#34;]]

        # Make a list of poits if they are retrograde or not.

        self.points_retrograde = []

        for planet in self.user.planets_list:
            self.points_retrograde.append(planet[&#34;retrograde&#34;])

        self.points_retrograde = self.points_retrograde + [False,
                                                           False, False, False]

        # Makes the sign number list.

        self.houses_sign_graph = []
        for h in self.user.houses_list:
            self.houses_sign_graph.append(h[&#39;sign_num&#39;])

        if self.type == &#34;Natal&#34;:
            natal_aspects_instance = kr.utilities.NatalAspects(self.user, new_settings_file=self.settings_file)
            self.aspects_list = natal_aspects_instance.get_aspects()

        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

            # Kerykeion instance
            self.t_user = second_obj

            if not hasattr(self.t_user, &#34;sun&#34;):
                print(f&#34;Generating kerykeion object for {self.t_user.name}...&#34;)
                self.t_user.get_all()

            # Make a list for the absolute degrees of the points of the graphic.

            self.t_points_deg_ut = self.t_user.planets_degrees + [self.t_user.houses_degree_ut[0],
                                                                  self.t_user.houses_degree_ut[
                                                                      9], self.t_user.houses_degree_ut[6],
                                                                  self.t_user.houses_degree_ut[3]]

            # Make a list of the relative degrees of the points in the graphic.

            self.t_points_deg = []
            for planet in self.t_user.planets_list:
                self.t_points_deg.append(planet[&#34;position&#34;])

            self.t_points_deg = self.t_points_deg + [self.t_user.houses_list[0][&#34;position&#34;],
                                                     self.t_user.houses_list[9][&#34;position&#34;], self.t_user.houses_list[6][&#34;position&#34;],
                                                     self.t_user.houses_list[3][&#34;position&#34;]]

            # Make list of the poits sign.

            self.t_points_sign = []

            for planet in self.t_user.planets_list:
                self.t_points_sign.append(planet[&#34;sign_num&#34;])

            self.t_points_sign = self.t_points_sign + [self.t_user.houses_list[0][&#34;sign_num&#34;],
                                                       self.t_user.houses_list[9][&#34;sign_num&#34;], self.t_user.houses_list[6][&#34;sign_num&#34;],
                                                       self.t_user.houses_list[3][&#34;sign_num&#34;]]

            # Make a list of poits if they are retrograde or not.

            self.t_points_retrograde = []

            for planet in self.t_user.planets_list:
                self.t_points_retrograde.append(planet[&#34;retrograde&#34;])

            self.t_points_retrograde = self.t_points_retrograde + [False,
                                                                   False, False, False]

            self.t_houses_sign_graph = []
            for h in self.t_user.houses_list:
                self.t_houses_sign_graph.append(h[&#39;sign_num&#39;])

        # screen size
        if self.type == &#34;Natal&#34;:
            self.screen_width = 772.2
        else:
            self.screen_width = 1200
        self.screen_height = 772.2

        # check for home
        self.home_location = self.user.city
        self.home_geolat = self.user.city_lat
        self.home_geolon = self.user.city_long
        self.home_countrycode = self.user.nation
        self.home_timezonestr = self.user.city_tz

        print(f&#39;{self.user.name} birth location: {self.home_location}, {self.home_geolat}, {self.home_geolon}&#39;)

        # default location
        self.location = self.home_location
        self.geolat = float(self.home_geolat)
        self.geolon = float(self.home_geolon)
        self.countrycode = self.home_countrycode
        self.timezonestr = self.home_timezonestr

        # current datetime
        now = datetime.datetime.now()

        # aware datetime object
        dt_input = datetime.datetime(
            now.year, now.month, now.day, now.hour, now.minute, now.second)
        dt = pytz.timezone(self.timezonestr).localize(dt_input)

        # naive utc datetime object
        dt_utc = dt.replace(tzinfo=None) - dt.utcoffset()

        # Default
        self.name = self.user.name
        self.charttype = self.type
        self.year = self.user.utc.year
        self.month = self.user.utc.month
        self.day = self.user.utc.day
        self.hour = self.user.utc.hour + self.user.utc.minute/100
        self.timezone = self.offsetToTz(dt.utcoffset())
        self.altitude = 25
        self.geonameid = None

        # Transit

        if self.type == &#34;Transit&#34;:
            self.t_geolon = self.geolon
            self.t_geolat = self.geolat
            self.t_altitude = self.altitude
            self.t_name = self.language_settings[&#39;transit_name&#39;]
            self.t_year = dt_utc.year
            self.t_month = dt_utc.month
            self.t_day = dt_utc.day
            self.t_hour = self.decHourJoin(
                dt_utc.hour, dt_utc.minute, dt_utc.second)
            self.t_timezone = self.offsetToTz(dt.utcoffset())
            self.t_altitude = 25
            self.t_geonameid = None

        # configuration
        # ZOOM 1 = 100%
        self.zoom = 1

        # 12 zodiacs
        self.zodiac = [&#39;aries&#39;, &#39;taurus&#39;, &#39;gemini&#39;, &#39;cancer&#39;, &#39;leo&#39;, &#39;virgo&#39;,
                       &#39;libra&#39;, &#39;scorpio&#39;, &#39;sagittarius&#39;, &#39;capricorn&#39;, &#39;aquarius&#39;, &#39;pisces&#39;]
        self.zodiac_short = [&#39;Ari&#39;, &#39;Tau&#39;, &#39;Gem&#39;, &#39;Cnc&#39;, &#39;Leo&#39;,
                             &#39;Vir&#39;, &#39;Lib&#39;, &#39;Sco&#39;, &#39;Sgr&#39;, &#39;Cap&#39;, &#39;Aqr&#39;, &#39;Psc&#39;]
        self.zodiac_color = [&#39;#482900&#39;, &#39;#6b3d00&#39;, &#39;#5995e7&#39;, &#39;#2b4972&#39;, &#39;#c54100&#39;,
                             &#39;#2b286f&#39;, &#39;#69acf1&#39;, &#39;#ffd237&#39;, &#39;#ff7200&#39;, &#39;#863c00&#39;, &#39;#4f0377&#39;, &#39;#6cbfff&#39;]
        self.zodiac_element = [&#39;fire&#39;, &#39;earth&#39;, &#39;air&#39;, &#39;water&#39;, &#39;fire&#39;,
                               &#39;earth&#39;, &#39;air&#39;, &#39;water&#39;, &#39;fire&#39;, &#39;earth&#39;, &#39;air&#39;, &#39;water&#39;]

        # get color configuration

        # Immediately generate template.
        self.template = self.makeTemplate()


    def parse_json_settings(self, settings_file, lang: str):
        &#34;&#34;&#34;
        Parse the settings file.
        &#34;&#34;&#34;
        with open(settings_file, &#39;r&#39;) as f:
            settings = json.load(f)

        self.language_settings = settings[&#39;language_settings&#39;].get(
            lang, &#34;EN&#34;)
        self.colors_settings = settings[&#39;colors&#39;]
        self.planets_settings = settings[&#39;planets&#39;]
        self.aspects_settings = settings[&#39;aspects&#39;]

        
    def makeTemplate(self, printing=None):
        # self.type = &#34;Transit&#34;
        # empty element points
        self.fire = 0.0
        self.earth = 0.0
        self.air = 0.0
        self.water = 0.0

        # Transit module data
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            # grab transiting module data

            self.t_planets_sign = self.t_points_sign
            self.t_planets_degree = self.t_points_deg
            self.t_planets_degree_ut = self.t_points_deg_ut
            self.t_planets_retrograde = self.t_points_retrograde
            self.t_houses_list = self.t_user.houses_list
            self.t_houses_sign = self.t_houses_sign_graph
            self.t_houses_degree_ut = self.t_user.houses_degree_ut

        # grab normal module data
        self.planets_sign = self.points_sign
        self.planets_degree = self.points_deg
        self.planets_degree_ut = self.points_deg_ut
        self.planets_retrograde = self.points_retrograde
        self.houses_list = self.user.houses_list
        self.houses_sign = self.houses_sign_graph
        self.houses_degree_ut = self.user.houses_degree_ut
        self.lunar_phase = self.user.lunar_phase
        #

        # width and height from screen
        ratio = float(self.screen_width) / float(self.screen_height)
        if ratio &lt; 1.3:  # 1280x1024
            wm_off = 130
        else:  # 1024x768, 800x600, 1280x800, 1680x1050
            wm_off = 100

        # Viewbox and sizing
        svgHeight = &#34;100%&#34;  # self.screen_height-wm_off
        svgWidth = &#34;100%&#34;  #  self.screen_width-5.0
        # svgHeight=self.screen_height-wm_off
        # svgWidth=(770.0*svgHeight)/540.0
        # svgWidth=float(self.screen_width)-25.0
        rotate = &#34;0&#34;
        translate = &#34;0&#34;
        # Defoult:
        # viewbox = &#39;0 0 772.2 546.0&#39; #297mm * 2.6 + 210mm * 2.6
        if self.type == &#34;Natal&#34;:
            viewbox = &#39;0 0 772.2 546.0&#39;  # 297mm * 2.6 + 210mm * 2.6
        else:
            viewbox = &#39;0 0 1000 546.0&#39;

        # template dictionary
        td = dict()
        r = 240
        self.c1 = 0
        self.c2 = 36
        self.c3 = 120

        # transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            td[&#39;transitRing&#39;] = self.transitRing(r)
            td[&#39;degreeRing&#39;] = self.degreeTransitRing(r)
            # circles
            td[&#39;c1&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-36) + &#39;&#34;&#39;
            td[&#39;c1style&#39;] = &#39;fill: none; stroke: %s; stroke-width: 1px; stroke-opacity:.4;&#39; % (
                self.colors_settings[&#39;zodiac_transit_ring_2&#39;])
            td[&#39;c2&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-72) + &#39;&#34;&#39;
            td[&#39;c2style&#39;] = &#39;fill: %s; fill-opacity:.4; stroke: %s; stroke-opacity:.4; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_transit_ring_1&#39;])
            td[&#39;c3&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-160) + &#39;&#34;&#39;
            td[&#39;c3style&#39;] = &#39;fill: %s; fill-opacity:.8; stroke: %s; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_transit_ring_0&#39;])
            td[&#39;makeAspects&#39;] = self.makeAspectsTransit(r, (r-160))
            td[&#39;makeAspectGrid&#39;] = self.makeAspectTransitGrid(r)
            td[&#39;makePatterns&#39;] = &#39;&#39;
            td[&#39;chart_width&#39;] = self.full_width
        else:
            td[&#39;transitRing&#39;] = &#34;&#34;
            td[&#39;degreeRing&#39;] = self.degreeRing(r)
            # circles
            td[&#39;c1&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c1) + &#39;&#34;&#39;
            td[&#39;c1style&#39;] = &#39;fill: none; stroke: %s; stroke-width: 1px; &#39; % (
                self.colors_settings[&#39;zodiac_radix_ring_2&#39;])
            td[&#39;c2&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c2) + &#39;&#34;&#39;
            td[&#39;c2style&#39;] = &#39;fill: %s; fill-opacity:.2; stroke: %s; stroke-opacity:.4; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_radix_ring_1&#39;])
            td[&#39;c3&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
                str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c3) + &#39;&#34;&#39;
            td[&#39;c3style&#39;] = &#39;fill: %s; fill-opacity:.8; stroke: %s; stroke-width: 1px&#39; % (
                self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_radix_ring_0&#39;])
            td[&#39;makeAspects&#39;] = self.makeAspects(r, (r-self.c3))
            td[&#39;makeAspectGrid&#39;] = self.makeAspectGrid(r)
            td[&#39;makePatterns&#39;] = self.makePatterns()
            td[&#39;chart_width&#39;] = self.natal_width

        td[&#39;circleX&#39;] = str(0)
        td[&#39;circleY&#39;] = str(0)
        td[&#39;svgWidth&#39;] = str(svgWidth)
        td[&#39;svgHeight&#39;] = str(svgHeight)
        td[&#39;viewbox&#39;] = viewbox
        if self.type == &#34;Composite&#34;:
            td[&#39;stringTitle&#39;] = f&#34;{self.name} {self.language_settings[&#39;&amp;&#39;]} {self.t_user.name}&#34;
        elif self.type == &#34;Transit&#34;:
            td[&#39;stringTitle&#39;] = f&#34;{self.language_settings[&#39;transits&#39;]} {self.t_user.day}/{self.t_user.month}/{self.t_user.year}&#34;
        else:
            td[&#39;stringTitle&#39;] = self.name

        # Tipo di carta
        if self.type == &#34;Composite&#34; or self.name == &#34;Transit&#34;:
            td[&#39;stringName&#39;] = f&#34;{self.name}:&#34;
        else:
            td[&#39;stringName&#39;] = f&#39;{self.language_settings[&#34;info&#34;]}:&#39;

        # bottom left

        td[&#39;bottomLeft1&#39;] = &#39;&#39;
        td[&#39;bottomLeft2&#39;] = &#39;&#39;
        td[&#39;bottomLeft3&#39;] = f&#39;{self.language_settings.get(&#34;lunar_phase&#34;, &#34;Lunar Phase&#34;)}: {self.language_settings.get(&#34;day&#34;, &#34;Day&#34;)} {self.lunar_phase.get(&#34;moon_phase&#34;, &#34;&#34;)}&#39;
        td[&#39;bottomLeft4&#39;] = &#39;&#39;

        # lunar phase
        deg = self.lunar_phase[&#39;degrees_between_s_m&#39;]

        if(deg &lt; 90.0):
            maxr = deg
            if(deg &gt; 80.0):
                maxr = maxr*maxr
            lfcx = 20.0+(deg/90.0)*(maxr+10.0)
            lfr = 10.0+(deg/90.0)*maxr
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_0&#34;], self.colors_settings[&#34;lunar_phase_1&#34;]

        elif(deg &lt; 180.0):
            maxr = 180.0-deg
            if(deg &lt; 100.0):
                maxr = maxr*maxr
            lfcx = 20.0+((deg-90.0)/90.0*(maxr+10.0))-(maxr+10.0)
            lfr = 10.0+maxr-((deg-90.0)/90.0*maxr)
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_1&#34;], self.colors_settings[&#34;lunar_phase_0&#34;]

        elif(deg &lt; 270.0):
            maxr = deg-180.0
            if(deg &gt; 260.0):
                maxr = maxr*maxr
            lfcx = 20.0+((deg-180.0)/90.0*(maxr+10.0))
            lfr = 10.0+((deg-180.0)/90.0*maxr)
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_1&#34;], self.colors_settings[&#34;lunar_phase_0&#34;]

        elif(deg &lt; 361):
            maxr = 360.0-deg
            if(deg &lt; 280.0):
                maxr = maxr*maxr
            lfcx = 20.0+((deg-270.0)/90.0*(maxr+10.0))-(maxr+10.0)
            lfr = 10.0+maxr-((deg-270.0)/90.0*maxr)
            lffg, lfbg = self.colors_settings[&#34;lunar_phase_0&#34;], self.colors_settings[&#34;lunar_phase_1&#34;]

        td[&#39;lunar_phase_fg&#39;] = lffg
        td[&#39;lunar_phase_bg&#39;] = lfbg
        td[&#39;lunar_phase_cx&#39;] = lfcx
        td[&#39;lunar_phase_r&#39;] = lfr
        td[&#39;lunar_phase_outline&#39;] = self.colors_settings[&#34;lunar_phase_2&#34;]

        # rotation based on latitude
        td[&#39;lunar_phase_rotate&#39;] = (-90.0-self.geolat)

        # stringlocation
        if len(self.location) &gt; 35:
            split = self.location.split(&#34;,&#34;)
            if len(split) &gt; 1:
                td[&#39;stringLocation&#39;] = split[0]+&#34;, &#34;+split[-1]
                if len(td[&#39;stringLocation&#39;]) &gt; 35:
                    td[&#39;stringLocation&#39;] = td[&#39;stringLocation&#39;][:35]+&#34;...&#34;
            else:
                td[&#39;stringLocation&#39;] = self.location[:35]+&#34;...&#34;
        else:
            td[&#39;stringLocation&#39;] = self.location

        # td[&#39;stringDateTime&#39;]= str(self.user.year)+&#39;-%(#1)02d-%(#2)02d %(#3)02d:%(#4)02d:%(#5)02d&#39; % {&#39;#1&#39;:self.user.month,&#39;#2&#39;:self.user.day,&#39;#3&#39;:self.user.hours,&#39;#4&#39;:self.user.minuts,&#39;#5&#39;:00} + self.decTzStr(self.timezone)
        td[&#39;stringDateTime&#39;] = f&#39;{self.user.year}-{self.user.month}-{self.user.day} {self.user.hours:02d}:{self.user.minuts:02d}&#39;

        if self.type == &#34;Composite&#34;:
            td[&#39;stringLat&#39;] = f&#39;{self.t_user.name}: &#39;
            td[&#39;stringLon&#39;] = self.t_user.city
            td[&#39;stringPosition&#39;] = f&#39;{self.t_user.year}-{self.t_user.month}-{self.t_user.day} {self.t_user.hours:02d}:{self.t_user.minuts:02d}&#39;

        else:
            td[&#39;stringLat&#39;] = &#34;%s: %s&#34; % (
                self.language_settings[&#39;latitude&#39;], self.lat2str(self.geolat))
            td[&#39;stringLon&#39;] = &#34;%s: %s&#34; % (
                self.language_settings[&#39;longitude&#39;], self.lon2str(self.geolon))
            td[&#39;stringPosition&#39;] = f&#34;{self.language_settings[&#39;type&#39;]}: {self.charttype}&#34;

        # paper_color_X
        td[&#39;paper_color_0&#39;] = self.colors_settings[&#34;paper_0&#34;]
        td[&#39;paper_color_1&#39;] = self.colors_settings[&#34;paper_1&#34;]

        # planets_color_X
        for i in range(len(self.planets_settings)):
            td[&#39;planets_color_%s&#39; %
                (i)] = self.colors_settings[&#34;planet_%s&#34; % (i)]

        # zodiac_color_X
        for i in range(12):
            td[&#39;zodiac_color_%s&#39; %
                (i)] = self.colors_settings[&#34;zodiac_icon_%s&#34; % (i)]

        # orb_color_X
        for i in range(len(self.aspects_settings)):
            td[&#39;orb_color_%s&#39; % (self.aspects_settings[i][&#39;degree&#39;])] = self.colors_settings[&#34;aspect_%s&#34; % (
                self.aspects_settings[i][&#39;degree&#39;])]

        # config
        td[&#39;cfgZoom&#39;] = str(self.zoom)
        td[&#39;cfgRotate&#39;] = rotate
        td[&#39;cfgTranslate&#39;] = translate

        # functions
        td[&#39;makeZodiac&#39;] = self.makeZodiac(r)
        td[&#39;makeHouses&#39;] = self.makeHouses(r)
        td[&#39;makePlanets&#39;] = self.makePlanets(r)
        td[&#39;makeElements&#39;] = self.makeElements(r)
        td[&#39;makePlanetGrid&#39;] = self.makePlanetGrid()
        td[&#39;makeHousesGrid&#39;] = self.makeHousesGrid()

        # read template
        with open(self.xml_svg, &#34;r&#34;) as output_file:
            f = open(self.xml_svg)
            template = Template(f.read()).substitute(td)

        # return filename

        return template

    def makeSVG(self):
        &#34;&#34;&#34;Prints out the SVG file in the specifide folder&#34;&#34;&#34;

        if not (self.template):
            self.template = self.makeTemplate()

        self.chartname = self.output_directory / f&#39;{self.name}{self.type}Chart.svg&#39;

        with open(self.chartname, &#34;w&#34;, encoding=&#39;utf-8&#39;) as output_file:
            output_file.write(self.template)

        return print(f&#34;SVG Generated Correctly in: {self.chartname}&#34;)

    # draw transit ring
    def transitRing(self, r):
        out = &#39;&lt;circle cx=&#34;%s&#34; cy=&#34;%s&#34; r=&#34;%s&#34; style=&#34;fill: none; stroke: %s; stroke-width: 36px; stroke-opacity: .4;&#34;/&gt;&#39; % (
            r, r, r-18, self.colors_settings[&#39;paper_1&#39;])
        out += &#39;&lt;circle cx=&#34;%s&#34; cy=&#34;%s&#34; r=&#34;%s&#34; style=&#34;fill: none; stroke: %s; stroke-width: 1px; stroke-opacity: .6;&#34;/&gt;&#39; % (
            r, r, r, self.colors_settings[&#39;zodiac_transit_ring_3&#39;])
        return out

    # draw degree ring
    def degreeRing(self, r):
        out = &#39;&#39;
        for i in range(72):
            offset = float(i*5) - self.houses_degree_ut[6]
            if offset &lt; 0:
                offset = offset + 360.0
            elif offset &gt; 360:
                offset = offset - 360.0
            x1 = self.sliceToX(0, r-self.c1, offset) + self.c1
            y1 = self.sliceToY(0, r-self.c1, offset) + self.c1
            x2 = self.sliceToX(0, r+2-self.c1, offset) - 2 + self.c1
            y2 = self.sliceToY(0, r+2-self.c1, offset) - 2 + self.c1
            out += &#39;&lt;line x1=&#34;%s&#34; y1=&#34;%s&#34; x2=&#34;%s&#34; y2=&#34;%s&#34; style=&#34;stroke: %s; stroke-width: 1px; stroke-opacity:.9;&#34;/&gt;\n&#39; % (
                x1, y1, x2, y2, self.colors_settings[&#39;paper_0&#39;])
        return out

    def degreeTransitRing(self, r):
        out = &#39;&#39;
        for i in range(72):
            offset = float(i*5) - self.houses_degree_ut[6]
            if offset &lt; 0:
                offset = offset + 360.0
            elif offset &gt; 360:
                offset = offset - 360.0
            x1 = self.sliceToX(0, r, offset)
            y1 = self.sliceToY(0, r, offset)
            x2 = self.sliceToX(0, r+2, offset) - 2
            y2 = self.sliceToY(0, r+2, offset) - 2
            out += &#39;&lt;line x1=&#34;%s&#34; y1=&#34;%s&#34; x2=&#34;%s&#34; y2=&#34;%s&#34; style=&#34;stroke: #F00; stroke-width: 1px; stroke-opacity:.9;&#34;/&gt;\n&#39; % (
                x1, y1, x2, y2)
        return out

    # floating latitude an longitude to string
    def lat2str(self, coord):
        sign = self.language_settings[&#34;north&#34;]
        if coord &lt; 0.0:
            sign = self.language_settings[&#34;south&#34;]
            coord = abs(coord)
        deg = int(coord)
        min = int((float(coord) - deg) * 60)
        sec = int(round(float(((float(coord) - deg) * 60) - min) * 60.0))
        return &#34;%s°%s&#39;%s\&#34; %s&#34; % (deg, min, sec, sign)

    def lon2str(self, coord):
        sign = self.language_settings[&#34;east&#34;]
        if coord &lt; 0.0:
            sign = self.language_settings[&#34;west&#34;]
            coord = abs(coord)
        deg = int(coord)
        min = int((float(coord) - deg) * 60)
        sec = int(round(float(((float(coord) - deg) * 60) - min) * 60.0))
        return &#34;%s°%s&#39;%s\&#34; %s&#34; % (deg, min, sec, sign)

    # decimal hour to minutes and seconds
    def decHour(self, input):
        hours = int(input)
        mands = (input-hours)*60.0
        mands = round(mands, 5)
        minutes = int(mands)
        seconds = int(round((mands-minutes)*60))
        return [hours, minutes, seconds]

    # join hour, minutes, seconds, timezone integere to hour float
    def decHourJoin(self, inH, inM, inS):
        dh = float(inH)
        dm = float(inM)/60
        ds = float(inS)/3600
        output = dh + dm + ds
        return output

    # Datetime offset to float in hours
    def offsetToTz(self, dtoffset):
        dh = float(dtoffset.days * 24)
        sh = float(dtoffset.seconds / 3600.0)
        output = dh + sh
        return output

    # decimal timezone string
    def decTzStr(self, tz):
        if tz &gt; 0:
            h = int(tz)
            m = int((float(tz)-float(h))*float(60))
            return &#34; [+%(#1)02d:%(#2)02d]&#34; % {&#39;#1&#39;: h, &#39;#2&#39;: m}
        else:
            h = int(tz)
            m = int((float(tz)-float(h))*float(60))/-1
            return &#34; [-%(#1)02d:%(#2)02d]&#34; % {&#39;#1&#39;: h/-1, &#39;#2&#39;: m}

    # degree difference
    def degreeDiff(self, a, b):
        out = float()
        if a &gt; b:
            out = a - b
        if a &lt; b:
            out = b-a
        if out &gt; 180.0:
            out = 360.0-out
        return out

    # decimal to degrees (a°b&#39;c&#34;)
    def dec2deg(self, dec, type=&#34;3&#34;):
        dec = float(dec)
        a = int(dec)
        a_new = (dec-float(a)) * 60.0
        b_rounded = int(round(a_new))
        b = int(a_new)
        c = int(round((a_new-float(b))*60.0))
        if type == &#34;3&#34;:
            out = &#39;%(#1)02d&amp;#176;%(#2)02d&amp;#39;%(#3)02d&amp;#34;&#39; % {
                &#39;#1&#39;: a, &#39;#2&#39;: b, &#39;#3&#39;: c}
        elif type == &#34;2&#34;:
            out = &#39;%(#1)02d&amp;#176;%(#2)02d&amp;#39;&#39; % {&#39;#1&#39;: a, &#39;#2&#39;: b_rounded}
        elif type == &#34;1&#34;:
            out = &#39;%(#1)02d&amp;#176;&#39; % {&#39;#1&#39;: a}
        return str(out)

    # draw svg aspects: ring, aspect ring, degreeA degreeB
    def drawAspect(self, r, ar, degA, degB, color):
        offset = (int(self.houses_degree_ut[6]) / -1) + int(degA)
        x1 = self.sliceToX(0, ar, offset) + (r-ar)
        y1 = self.sliceToY(0, ar, offset) + (r-ar)
        offset = (int(self.houses_degree_ut[6]) / -1) + int(degB)
        x2 = self.sliceToX(0, ar, offset) + (r-ar)
        y2 = self.sliceToY(0, ar, offset) + (r-ar)
        out = &#39;            &lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
            y2)+&#39;&#34; style=&#34;stroke: &#39;+color+&#39;; stroke-width: 1; stroke-opacity: .9;&#34;/&gt;\n&#39;
        return out

    def sliceToX(self, slice, r, offset):
        plus = (math.pi * offset) / 180
        radial = ((math.pi/6) * slice) + plus
        return r * (math.cos(radial)+1)

    def sliceToY(self, slice, r, offset):
        plus = (math.pi * offset) / 180
        radial = ((math.pi/6) * slice) + plus
        return r * ((math.sin(radial)/-1)+1)

    def zodiacSlice(self, num, r, style,  type):
        # pie slices
        offset = 360 - self.houses_degree_ut[6]
        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 0
        else:
            dropin = self.c1
        slice = &#39;&lt;path d=&#34;M&#39; + str(r) + &#39;,&#39; + str(r) + &#39; L&#39; + str(dropin + self.sliceToX(num, r-dropin, offset)) + &#39;,&#39; + str(dropin + self.sliceToY(num, r-dropin, offset)) + &#39; A&#39; + str(
            r-dropin) + &#39;,&#39; + str(r-dropin) + &#39; 0 0,0 &#39; + str(dropin + self.sliceToX(num+1, r-dropin, offset)) + &#39;,&#39; + str(dropin + self.sliceToY(num+1, r-dropin, offset)) + &#39; z&#34; style=&#34;&#39; + style + &#39;&#34;/&gt;&#39;
        # symbols
        offset = offset + 15
        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 54
        else:
            dropin = 18+self.c1
        sign = &#39;&lt;g transform=&#34;translate(-16,-16)&#34;&gt;&lt;use x=&#34;&#39; + str(dropin + self.sliceToX(num, r-dropin, offset)) + &#39;&#34; y=&#34;&#39; + str(
            dropin + self.sliceToY(num, r-dropin, offset)) + &#39;&#34; xlink:href=&#34;#&#39; + type + &#39;&#34; /&gt;&lt;/g&gt;\n&#39;
        return slice + &#39;\n&#39; + sign

    def makeZodiac(self, r):
        output = &#34;&#34;
        for i in range(len(self.zodiac)):
            output = output + self.zodiacSlice(i, r, &#34;fill:&#34; + self.colors_settings[&#34;zodiac_bg_%s&#34; % (
                i)] + &#34;; fill-opacity: 0.5;&#34;, self.zodiac[i]) + &#39;\n&#39;
        return output

    def makeHouses(self, r):
        path = &#34;&#34;

        xr = 12
        for i in range(xr):
            # check transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 160
                roff = 72
                t_roff = 36
            else:
                dropin = self.c3
                roff = self.c1

            # offset is negative desc houses_degree_ut[6]
            offset = (
                int(self.houses_degree_ut[int(xr/2)]) / -1) + int(self.houses_degree_ut[i])
            x1 = self.sliceToX(0, (r-dropin), offset) + dropin
            y1 = self.sliceToY(0, (r-dropin), offset) + dropin
            x2 = self.sliceToX(0, r-roff, offset) + roff
            y2 = self.sliceToY(0, r-roff, offset) + roff

            if i &lt; (xr-1):
                text_offset = offset + \
                    int(self.degreeDiff(self.houses_degree_ut[(
                        i+1)], self.houses_degree_ut[i]) / 2)
            else:
                text_offset = offset + \
                    int(self.degreeDiff(
                        self.houses_degree_ut[0], self.houses_degree_ut[(xr-1)]) / 2)

            # mc, asc, dsc, ic
            if i == 0:
                linecolor = self.planets_settings[12][&#39;color&#39;]
            elif i == 9:
                linecolor = self.planets_settings[13][&#39;color&#39;]
            elif i == 6:
                linecolor = self.planets_settings[14][&#39;color&#39;]
            elif i == 3:
                linecolor = self.planets_settings[15][&#39;color&#39;]
            else:
                linecolor = self.colors_settings[&#39;houses_radix_line&#39;]

            # Transit houses lines.
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

                # Degrees for point zero.

                zeropoint = 360 - self.houses_degree_ut[6]
                t_offset = zeropoint + self.t_houses_degree_ut[i]
                if t_offset &gt; 360:
                    t_offset = t_offset - 360
                t_x1 = self.sliceToX(0, (r-t_roff), t_offset) + t_roff
                t_y1 = self.sliceToY(0, (r-t_roff), t_offset) + t_roff
                t_x2 = self.sliceToX(0, r, t_offset)
                t_y2 = self.sliceToY(0, r, t_offset)
                if i &lt; 11:
                    t_text_offset = t_offset + \
                        int(self.degreeDiff(self.t_houses_degree_ut[(
                            i+1)], self.t_houses_degree_ut[i]) / 2)
                else:
                    t_text_offset = t_offset + \
                        int(self.degreeDiff(
                            self.t_houses_degree_ut[0], self.t_houses_degree_ut[11]) / 2)
                # linecolor
                if i == 0 or i == 9 or i == 6 or i == 3:
                    t_linecolor = linecolor
                else:
                    t_linecolor = self.colors_settings[&#39;houses_transit_line&#39;]
                xtext = self.sliceToX(0, (r-8), t_text_offset) + 8
                ytext = self.sliceToY(0, (r-8), t_text_offset) + 8

                if self.type == &#34;Transit&#34;:
                    path = path + &#39;&lt;text style=&#34;fill: #00f; fill-opacity: 0; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                        str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                        &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;
                    path = path + &#39;&lt;line x1=&#34;&#39;+str(t_x1)+&#39;&#34; y1=&#34;&#39;+str(t_y1)+&#39;&#34; x2=&#34;&#39;+str(t_x2)+&#39;&#34; y2=&#34;&#39;+str(
                        t_y2)+&#39;&#34; style=&#34;stroke: &#39;+t_linecolor+&#39;; stroke-width: 2px; stroke-opacity:0;&#34;/&gt;\n&#39;

                else:
                    path = path + &#39;&lt;text style=&#34;fill: #00f; fill-opacity: .4; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                        str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                        &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;
                    path = path + &#39;&lt;line x1=&#34;&#39;+str(t_x1)+&#39;&#34; y1=&#34;&#39;+str(t_y1)+&#39;&#34; x2=&#34;&#39;+str(t_x2)+&#39;&#34; y2=&#34;&#39;+str(
                        t_y2)+&#39;&#34; style=&#34;stroke: &#39;+t_linecolor+&#39;; stroke-width: 2px; stroke-opacity:.3;&#34;/&gt;\n&#39;

            # if transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 84

            dropin = 48

            xtext = self.sliceToX(
                0, (r-dropin), text_offset) + dropin  # was 132
            ytext = self.sliceToY(
                0, (r-dropin), text_offset) + dropin  # was 132
            path = path + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+linecolor+&#39;; stroke-width: 2px; stroke-dasharray:3,2; stroke-opacity:.4;&#34;/&gt;\n&#39;
            path = path + &#39;&lt;text style=&#34;fill: #f00; fill-opacity: .6; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;

        return path

    def makePlanets(self, r):

        planets_degut = {}

        diff = range(len(self.planets_settings))
        for i in range(len(self.planets_settings)):
            if self.planets_settings[i][&#39;visible&#39;] == 1:
                # list of planets sorted by degree
                planets_degut[self.planets_degree_ut[i]] = i

            # element: get extra points if planet is in own zodiac
            pz = self.planets_settings[i][&#39;zodiac_relation&#39;]
            cz = self.planets_sign[i]
            extrapoints = 0
            if pz != -1:
                for e in range(len(pz.split(&#39;,&#39;))):
                    if int(pz.split(&#39;,&#39;)[e]) == int(cz):
                        extrapoints = 10

            # calculate element points for all planets
            ele = self.zodiac_element[self.planets_sign[i]]
            if ele == &#34;fire&#34;:
                self.fire = self.fire + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints
            elif ele == &#34;earth&#34;:
                self.earth = self.earth + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints
            elif ele == &#34;air&#34;:
                self.air = self.air + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints
            elif ele == &#34;water&#34;:
                self.water = self.water + \
                    self.planets_settings[i][&#39;element_points&#39;] + extrapoints

        output = &#34;&#34;
        keys = list(planets_degut.keys())
        keys.sort()
        switch = 0

        planets_degrouped = {}
        groups = []
        planets_by_pos = list(range(len(planets_degut)))
        planet_drange = 3.4
        # get groups closely together
        group_open = False
        for e in range(len(keys)):
            i = planets_degut[keys[e]]
            # get distances between planets
            if e == 0:
                prev = self.planets_degree_ut[planets_degut[keys[-1]]]
                next = self.planets_degree_ut[planets_degut[keys[1]]]
            elif e == (len(keys)-1):
                prev = self.planets_degree_ut[planets_degut[keys[e-1]]]
                next = self.planets_degree_ut[planets_degut[keys[0]]]
            else:
                prev = self.planets_degree_ut[planets_degut[keys[e-1]]]
                next = self.planets_degree_ut[planets_degut[keys[e+1]]]
            diffa = self.degreeDiff(prev, self.planets_degree_ut[i])
            diffb = self.degreeDiff(next, self.planets_degree_ut[i])
            planets_by_pos[e] = [i, diffa, diffb]
            # print &#34;%s %s %s&#34; % (self.planets_settings[i][&#39;label&#39;],diffa,diffb)
            if (diffb &lt; planet_drange):
                if group_open:
                    groups[-1].append([e, diffa, diffb,
                                      self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
                else:
                    group_open = True
                    groups.append([])
                    groups[-1].append([e, diffa, diffb,
                                      self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
            else:
                if group_open:
                    groups[-1].append([e, diffa, diffb,
                                      self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
                group_open = False

        def zero(x): return 0
        planets_delta = list(map(zero, range(len(self.planets_settings))))

        # print groups
        # print planets_by_pos
        for a in range(len(groups)):
            # Two grouped planets
            if len(groups[a]) == 2:
                next_to_a = groups[a][0][0]-1
                if groups[a][1][0] == (len(planets_by_pos)-1):
                    next_to_b = 0
                else:
                    next_to_b = groups[a][1][0]+1
                # if both planets have room
                if (groups[a][0][1] &gt; (2*planet_drange)) &amp; (groups[a][1][2] &gt; (2*planet_drange)):
                    planets_delta[groups[a][0][0]] = - \
                        (planet_drange-groups[a][0][2])/2
                    planets_delta[groups[a][1][0]] = + \
                        (planet_drange-groups[a][0][2])/2
                # if planet a has room
                elif (groups[a][0][1] &gt; (2*planet_drange)):
                    planets_delta[groups[a][0][0]] = -planet_drange
                # if planet b has room
                elif (groups[a][1][2] &gt; (2*planet_drange)):
                    planets_delta[groups[a][1][0]] = +planet_drange

                # if planets next to a and b have room move them
                elif (planets_by_pos[next_to_a][1] &gt; (2.4*planet_drange)) &amp; (planets_by_pos[next_to_b][2] &gt; (2.4*planet_drange)):
                    planets_delta[(next_to_a)] = (
                        groups[a][0][1]-planet_drange*2)
                    planets_delta[groups[a][0][0]] = -planet_drange*.5
                    planets_delta[next_to_b] = - \
                        (groups[a][1][2]-planet_drange*2)
                    planets_delta[groups[a][1][0]] = +planet_drange*.5

                # if planet next to a has room move them
                elif (planets_by_pos[next_to_a][1] &gt; (2*planet_drange)):
                    planets_delta[(next_to_a)] = (
                        groups[a][0][1]-planet_drange*2.5)
                    planets_delta[groups[a][0][0]] = -planet_drange*1.2

                # if planet next to b has room move them
                elif (planets_by_pos[next_to_b][2] &gt; (2*planet_drange)):
                    planets_delta[next_to_b] = - \
                        (groups[a][1][2]-planet_drange*2.5)
                    planets_delta[groups[a][1][0]] = +planet_drange*1.2

            # Three grouped planets or more
            xl = len(groups[a])
            if xl &gt;= 3:

                available = groups[a][0][1]
                for f in range(xl):
                    available += groups[a][f][2]
                need = (3*planet_drange)+(1.2*(xl-1)*planet_drange)
                leftover = available - need
                xa = groups[a][0][1]
                xb = groups[a][(xl-1)][2]

                # center
                if (xa &gt; (need*.5)) &amp; (xb &gt; (need*.5)):
                    startA = xa - (need*.5)
                # position relative to next planets
                else:
                    startA = (leftover/(xa+xb))*xa
                    startB = (leftover/(xa+xb))*xb

                if available &gt; need:
                    planets_delta[groups[a][0][0]] = startA - \
                        groups[a][0][1]+(1.5*planet_drange)
                    for f in range(xl-1):
                        planets_delta[groups[a][(
                            f+1)][0]] = 1.2*planet_drange+planets_delta[groups[a][f][0]]-groups[a][f][2]

        for e in range(len(keys)):
            i = planets_degut[keys[e]]

            # coordinates
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                if 22 &lt; i &lt; 27:
                    rplanet = 76
                elif switch == 1:
                    rplanet = 110
                    switch = 0
                else:
                    rplanet = 130
                    switch = 1
            else:
                # if 22 &lt; i &lt; 27 it is asc,mc,dsc,ic (angles of chart)
                # put on special line (rplanet is range from outer ring)
                amin, bmin, cmin = 0, 0, 0

                if 22 &lt; i &lt; 27:
                    rplanet = 40-cmin
                elif switch == 1:
                    rplanet = 74-amin
                    switch = 0
                else:
                    rplanet = 94-bmin
                    switch = 1

            rtext = 45

            offset = (int(self.houses_degree_ut[6]) / -1) + \
                int(self.planets_degree_ut[i]+planets_delta[e])
            trueoffset = (
                int(self.houses_degree_ut[6]) / -1) + int(self.planets_degree_ut[i])

            planet_x = self.sliceToX(0, (r-rplanet), offset) + rplanet
            planet_y = self.sliceToY(0, (r-rplanet), offset) + rplanet
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                scale = 0.8

            scale = 1
            # output planet
            output = output + &#39;&lt;g transform=&#34;translate(-&#39;+str(12*scale)+&#39;,-&#39;+str(12*scale)+&#39;)&#34;&gt;&lt;g transform=&#34;scale(&#39;+str(scale)+&#39;)&#34;&gt;&lt;use x=&#34;&#39; + str(
                planet_x*(1/scale)) + &#39;&#34; y=&#34;&#39; + str(planet_y*(1/scale)) + &#39;&#34; xlink:href=&#34;#&#39; + self.planets_settings[i][&#39;name&#39;] + &#39;&#34; /&gt;&lt;/g&gt;&lt;/g&gt;\n&#39;

        # make transit degut and display planets
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            group_offset = {}
            t_planets_degut = {}
            if self.type == &#34;Transit&#34;:
                list_range = len(self.planets_settings)-4
            else:
                list_range = len(self.planets_settings)
            for i in range(list_range):
                group_offset[i] = 0
                if self.planets_settings[i][&#39;visible&#39;] == 1:
                    t_planets_degut[self.t_planets_degree_ut[i]] = i
            t_keys = list(t_planets_degut.keys())
            t_keys.sort()

            # grab closely grouped planets
            groups = []
            in_group = False
            for e in range(len(t_keys)):
                i_a = t_planets_degut[t_keys[e]]
                if e == (len(t_keys)-1):
                    i_b = t_planets_degut[t_keys[0]]
                else:
                    i_b = t_planets_degut[t_keys[e+1]]

                a = self.t_planets_degree_ut[i_a]
                b = self.t_planets_degree_ut[i_b]
                diff = self.degreeDiff(a, b)
                if diff &lt;= 2.5:
                    if in_group:
                        groups[-1].append(i_b)
                    else:
                        groups.append([i_a])
                        groups[-1].append(i_b)
                        in_group = True
                else:
                    in_group = False
            # loop groups and set degrees display adjustment
            for i in range(len(groups)):
                if len(groups[i]) == 2:
                    group_offset[groups[i][0]] = -1.0
                    group_offset[groups[i][1]] = 1.0
                elif len(groups[i]) == 3:
                    group_offset[groups[i][0]] = -1.5
                    group_offset[groups[i][1]] = 0
                    group_offset[groups[i][2]] = 1.5
                elif len(groups[i]) == 4:
                    group_offset[groups[i][0]] = -2.0
                    group_offset[groups[i][1]] = -1.0
                    group_offset[groups[i][2]] = 1.0
                    group_offset[groups[i][3]] = 2.0

            switch = 0
            for e in range(len(t_keys)):
                i = t_planets_degut[t_keys[e]]

                if 22 &lt; i &lt; 27:
                    rplanet = 9
                elif switch == 1:
                    rplanet = 18
                    switch = 0
                else:
                    rplanet = 26
                    switch = 1

                zeropoint = 360 - self.houses_degree_ut[6]
                t_offset = zeropoint + self.t_planets_degree_ut[i]
                if t_offset &gt; 360:
                    t_offset = t_offset - 360
                planet_x = self.sliceToX(0, (r-rplanet), t_offset) + rplanet
                planet_y = self.sliceToY(0, (r-rplanet), t_offset) + rplanet
                output = output + &#39;&lt;g transform=&#34;translate(-6,-6)&#34;&gt;&lt;g transform=&#34;scale(0.5)&#34;&gt;&lt;use x=&#34;&#39; + str(
                    planet_x*2) + &#39;&#34; y=&#34;&#39; + str(planet_y*2) + &#39;&#34; xlink:href=&#34;#&#39; + self.planets_settings[i][&#39;name&#39;] + &#39;&#34; /&gt;&lt;/g&gt;&lt;/g&gt;\n&#39;
                # transit planet line
                x1 = self.sliceToX(0, r+3, t_offset) - 3
                y1 = self.sliceToY(0, r+3, t_offset) - 3
                x2 = self.sliceToX(0, r-3, t_offset) + 3
                y2 = self.sliceToY(0, r-3, t_offset) + 3
                output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                    y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 1px; stroke-opacity:.8;&#34;/&gt;\n&#39;

                # transit planet degree text
                rotate = self.houses_degree_ut[0] - self.t_planets_degree_ut[i]
                textanchor = &#34;end&#34;
                t_offset += group_offset[i]
                rtext = -3.0

                if -90 &gt; rotate &gt; -270:
                    rotate = rotate + 180.0
                    textanchor = &#34;start&#34;
                if 270 &gt; rotate &gt; 90:
                    rotate = rotate - 180.0
                    textanchor = &#34;start&#34;

                if textanchor == &#34;end&#34;:
                    xo = 1
                else:
                    xo = -1
                deg_x = self.sliceToX(0, (r-rtext), t_offset + xo) + rtext
                deg_y = self.sliceToY(0, (r-rtext), t_offset + xo) + rtext
                degree = int(t_offset)
                output += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (deg_x, deg_y)
                output += &#39;&lt;text transform=&#34;rotate(%s)&#34; text-anchor=&#34;%s&#39; % (
                    rotate, textanchor)
                output += &#39;&#34; style=&#34;fill: &#39; + \
                    self.planets_settings[i][&#39;color&#39;]+&#39;; font-size: 10px;&#34;&gt;&#39; + \
                    self.dec2deg(self.t_planets_degree[i], type=&#34;1&#34;)
                output += &#39;&lt;/text&gt;&lt;/g&gt;\n&#39;

            # check transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 36
            else:
                dropin = 0

            # planet line
            x1 = self.sliceToX(0, r-(dropin+3), offset) + (dropin+3)
            y1 = self.sliceToY(0, r-(dropin+3), offset) + (dropin+3)
            x2 = self.sliceToX(0, (r-(dropin-3)), offset) + (dropin-3)
            y2 = self.sliceToY(0, (r-(dropin-3)), offset) + (dropin-3)
            output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 2px; stroke-opacity:.6;&#34;/&gt;\n&#39;

            # check transit
            if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
                dropin = 160
            else:
                dropin = 120

            x1 = self.sliceToX(0, r-dropin, offset) + dropin
            y1 = self.sliceToY(0, r-dropin, offset) + dropin
            x2 = self.sliceToX(0, (r-(dropin-3)), offset) + (dropin-3)
            y2 = self.sliceToY(0, (r-(dropin-3)), offset) + (dropin-3)
            output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 2px; stroke-opacity:.6;&#34;/&gt;\n&#39;

        return output

    def makePatterns(self):
        &#34;&#34;&#34;
        * Stellium: At least four planets linked together in a series of continuous conjunctions.
        * Grand trine: Three trine aspects together.
        * Grand cross: Two pairs of opposing planets squared to each other.
        * T-Square: Two planets in opposition squared to a third.
        * Yod: Two qunicunxes together joined by a sextile.
        &#34;&#34;&#34;
        conj = {}  # 0
        opp = {}  # 10
        sq = {}  # 5
        tr = {}  # 6
        qc = {}  # 9
        sext = {}  # 3
        for i in range(len(self.planets_settings)):
            a = self.planets_degree_ut[i]
            qc[i] = {}
            sext[i] = {}
            opp[i] = {}
            sq[i] = {}
            tr[i] = {}
            conj[i] = {}
            # skip some points
            n = self.planets_settings[i][&#39;name&#39;]
            if n == &#39;earth&#39; or n == &#39;True_Node&#39; or n == &#39;osc. apogee&#39; or n == &#39;intp. apogee&#39; or n == &#39;intp. perigee&#39;:
                continue
            if n == &#39;Dsc&#39; or n == &#39;Ic&#39;:
                continue
            for j in range(len(self.planets_settings)):
                # skip some points
                n = self.planets_settings[j][&#39;name&#39;]
                if n == &#39;earth&#39; or n == &#39;True_Node&#39; or n == &#39;osc. apogee&#39; or n == &#39;intp. apogee&#39; or n == &#39;intp. perigee&#39;:
                    continue
                if n == &#39;Dsc&#39; or n == &#39;Ic&#39;:
                    continue
                b = self.planets_degree_ut[j]
                delta = float(self.degreeDiff(a, b))
                # check for opposition
                xa = float(self.aspects_settings[10][&#39;degree&#39;]) - \
                    float(self.aspects_settings[10][&#39;orb&#39;])
                xb = float(self.aspects_settings[10][&#39;degree&#39;]) + \
                    float(self.aspects_settings[10][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    opp[i][j] = True
                # check for conjunction
                xa = float(self.aspects_settings[0][&#39;degree&#39;]) - \
                    float(self.aspects_settings[0][&#39;orb&#39;])
                xb = float(self.aspects_settings[0][&#39;degree&#39;]) + \
                    float(self.aspects_settings[0][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    conj[i][j] = True
                # check for squares
                xa = float(self.aspects_settings[5][&#39;degree&#39;]) - \
                    float(self.aspects_settings[5][&#39;orb&#39;])
                xb = float(self.aspects_settings[5][&#39;degree&#39;]) + \
                    float(self.aspects_settings[5][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    sq[i][j] = True
                # check for qunicunxes
                xa = float(self.aspects_settings[9][&#39;degree&#39;]) - \
                    float(self.aspects_settings[9][&#39;orb&#39;])
                xb = float(self.aspects_settings[9][&#39;degree&#39;]) + \
                    float(self.aspects_settings[9][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    qc[i][j] = True
                # check for sextiles
                xa = float(self.aspects_settings[3][&#39;degree&#39;]) - \
                    float(self.aspects_settings[3][&#39;orb&#39;])
                xb = float(self.aspects_settings[3][&#39;degree&#39;]) + \
                    float(self.aspects_settings[3][&#39;orb&#39;])
                if(xa &lt;= delta &lt;= xb):
                    sext[i][j] = True

        yot = {}
        # check for double qunicunxes
        for k, v in qc.items():
            if len(qc[k]) &gt;= 2:
                # check for sextile
                for l, w in qc[k].items():
                    for m, x in qc[k].items():
                        if m in sext[l]:
                            if l &gt; m:
                                yot[&#39;%s,%s,%s&#39; % (k, m, l)] = [k, m, l]
                            else:
                                yot[&#39;%s,%s,%s&#39; % (k, l, m)] = [k, l, m]
        tsquare = {}
        # check for opposition
        for k, v in opp.items():
            if len(opp[k]) &gt;= 1:
                # check for square
                for l, w in opp[k].items():
                    for a, b in sq.items():
                        if k in sq[a] and l in sq[a]:
                            # print &#39;got tsquare %s %s %s&#39; % (a,k,l)
                            if k &gt; l:
                                tsquare[&#39;%s,%s,%s&#39; % (a, l, k)] = &#39;%s =&gt; %s, %s&#39; % (
                                    self.planets_settings[a][&#39;label&#39;], self.planets_settings[l][&#39;label&#39;], self.planets_settings[k][&#39;label&#39;])
                            else:
                                tsquare[&#39;%s,%s,%s&#39; % (a, k, l)] = &#39;%s =&gt; %s, %s&#39; % (
                                    self.planets_settings[a][&#39;label&#39;], self.planets_settings[k][&#39;label&#39;], self.planets_settings[l][&#39;label&#39;])
        stellium = {}
        # check for 4 continuous conjunctions
        for k, v in conj.items():
            if len(conj[k]) &gt;= 1:
                # first conjunction
                for l, m in conj[k].items():
                    if len(conj[l]) &gt;= 1:
                        for n, o in conj[l].items():
                            # skip 1st conj
                            if n == k:
                                continue
                            if len(conj[n]) &gt;= 1:
                                # third conjunction
                                for p, q in conj[n].items():
                                    # skip first and second conj
                                    if p == k or p == n:
                                        continue
                                    if len(conj[p]) &gt;= 1:
                                        # fourth conjunction
                                        for r, s in conj[p].items():
                                            # skip conj 1,2,3
                                            if r == k or r == n or r == p:
                                                continue

                                            l = [k, n, p, r]
                                            l.sort()
                                            stellium[&#39;%s %s %s %s&#39; % (l[0], l[1], l[2], l[3])] = &#39;%s %s %s %s&#39; % (
                                                self.planets_settings[l[0]
                                                                      ][&#39;label&#39;], self.planets_settings[l[1]][&#39;label&#39;],
                                                self.planets_settings[l[2]][&#39;label&#39;], self.planets_settings[l[3]][&#39;label&#39;])
        # print yots
        out = &#39;&lt;g transform=&#34;translate(-30,380)&#34;&gt;&#39;
        if len(yot) &gt;= 1:
            y = 0
            for k, v in yot.items():
                out += &#39;&lt;text y=&#34;%s&#34; style=&#34;fill:%s; font-size: 12px;&#34;&gt;%s&lt;/text&gt;\n&#39; % (
                    y, self.colors_settings[&#39;paper_0&#39;], (&#34;Yot&#34;))

                # first planet symbol
                out += &#39;&lt;g transform=&#34;translate(20,%s)&#34;&gt;&#39; % (y)
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                    self.planets_settings[yot[k][0]][&#39;name&#39;])

                # second planet symbol
                out += &#39;&lt;g transform=&#34;translate(30,%s)&#34;&gt;&#39; % (y)
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                    self.planets_settings[yot[k][1]][&#39;name&#39;])

                # third planet symbol
                out += &#39;&lt;g transform=&#34;translate(40,%s)&#34;&gt;&#39; % (y)
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                    self.planets_settings[yot[k][2]][&#39;name&#39;])

                y = y+14
        # finalize
        out += &#39;&lt;/g&gt;&#39;
        # return out
        return &#39;&#39;

    # Aspect and aspect grid functions for natal type charts.

    def makeAspects(self, r, ar):
        out = &#34;&#34;
        for element in self.aspects_list:
            out += self.drawAspect(r, ar, element[&#39;p1_abs_pos&#39;], element[&#39;p2_abs_pos&#39;],
                                   self.colors_settings[f&#34;aspect_{element[&#39;aspect_degrees&#39;]}&#34;])

        return out

    def makeAspectGrid(self, r):

        out = &#34;&#34;
        style = &#39;stroke:%s; stroke-width: 1px; stroke-opacity:.6; fill:none&#39; % (
            self.colors_settings[&#39;paper_0&#39;])
        xindent = 380
        yindent = 468
        box = 14
        revr = list(range(len(self.planets_settings)))
        revr.reverse()
        counter = 0
        for a in revr:
            counter += 1
            if self.planets_settings[a][&#39;visible&#39;] == 1:
                out += &#39;&lt;rect x=&#34;&#39;+str(xindent)+&#39;&#34; y=&#34;&#39;+str(yindent)+&#39;&#34; width=&#34;&#39;+str(
                    box)+&#39;&#34; height=&#34;&#39;+str(box)+&#39;&#34; style=&#34;&#39;+style+&#39;&#34;/&gt;\n&#39;
                out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;&#39;+str((xindent+2)*2.5)+&#39;&#34; y=&#34;&#39;+str(
                    (yindent+1)*2.5)+&#39;&#34; xlink:href=&#34;#&#39;+self.planets_settings[a][&#39;name&#39;]+&#39;&#34; /&gt;\n&#39;
                xindent = xindent + box
                yindent = yindent - box
                revr2 = list(range(a))
                revr2.reverse()
                xorb = xindent
                yorb = yindent + box
                for b in revr2:
                    if self.planets_settings[b][&#39;visible&#39;] == 1:
                        out += &#39;&lt;rect x=&#34;&#39;+str(xorb)+&#39;&#34; y=&#34;&#39;+str(yorb)+&#39;&#34; width=&#34;&#39;+str(
                            box)+&#39;&#34; height=&#34;&#39;+str(box)+&#39;&#34; style=&#34;&#39;+style+&#39;&#34;/&gt;\n&#39;
                        xorb = xorb+box
                        for element in self.aspects_list:
                            if (element[&#39;p1&#39;] == a and element[&#39;p2&#39;] == b) or (element[&#39;p1&#39;] == b and element[&#39;p2&#39;] == a):
                                out += &#39;&lt;use  x=&#34;&#39;+str(xorb-box+1)+&#39;&#34; y=&#34;&#39;+str(
                                    yorb+1)+&#39;&#34; xlink:href=&#34;#orb&#39;+str(element[&#39;aspect_degrees&#39;])+&#39;&#34; /&gt;\n&#39;

        return out

    # Aspect and aspect grid functions for transit type charts.

    def makeAspectsTransit(self, r, ar):
        out = &#34;&#34;

        self.aspects_list = kr.utilities.CompositeAspects(
            self.user, self.t_user, new_settings_file=self.settings_file
            ).get_aspects()

        for element in self.aspects_list:
            out += self.drawAspect(r, ar, element[&#39;p1_abs_pos&#39;], element[&#39;p2_abs_pos&#39;],
                                   self.colors_settings[f&#34;aspect_{element[&#39;aspect_degrees&#39;]}&#34;])

        return out

    def makeAspectTransitGrid(self, r):
        out = &#39;&lt;g transform=&#34;translate(500,310)&#34;&gt;&#39;
        out += &#39;&lt;text y=&#34;-15&#34; x=&#34;0&#34; style=&#34;fill:%s; font-size: 14px;&#34;&gt;%s&lt;/text&gt;\n&#39; % (
            self.colors_settings[&#39;paper_0&#39;], (f&#34;{self.language_settings[&#39;aspects&#39;]}:&#34;))
        line = 0
        nl = 0
        for i in range(len(self.aspects_list)):
            if i == 12:
                nl = 100
                # if len(self.aspects_list) &gt; 24:
                #     line = -1 * ( len(self.aspects_list) - 24) * 14
                # else:
                #     line = 0

                # temporary:
                line = 0

            if i == 24:
                nl = 200
                # if len(self.aspects_list) &gt; 36:
                #     line = -1 * ( len(self.aspects_list) - 36) * 14
                # else:
                #     line = 0
                line = 0

            if i == 36:
                nl = 300
                if len(self.aspects_list) &gt; 48:
                    line = -1 * (len(self.aspects_list) - 48) * 14
                else:
                    line = 0
            out += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (nl, line)
            # first planet symbol
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;3&#34; xlink:href=&#34;#%s&#34; /&gt;\n&#39; % (
                self.planets_settings[self.aspects_list[i][&#39;p1&#39;]][&#39;name&#39;])
            # aspect symbol
            out += &#39;&lt;use  x=&#34;15&#34; y=&#34;0&#34; xlink:href=&#34;#orb%s&#34; /&gt;\n&#39; % (
                self.aspects_settings[self.aspects_list[i][&#39;aid&#39;]][&#39;degree&#39;])
            # second planet symbol
            out += &#39;&lt;g transform=&#34;translate(30,0)&#34;&gt;&#39;
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;3&#34; xlink:href=&#34;#%s&#34; /&gt;\n&#39; % (
                self.planets_settings[self.aspects_list[i][&#39;p2&#39;]][&#39;name&#39;])
            out += &#39;&lt;/g&gt;&#39;
            # difference in degrees
            out += &#39;&lt;text y=&#34;8&#34; x=&#34;45&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;],
                self.dec2deg(self.aspects_list[i][&#39;orbit&#39;]))
            # line
            out += &#39;&lt;/g&gt;&#39;
            line = line + 14
        out += &#39;&lt;/g&gt;&#39;
        return out

    def makeElements(self, r):
        total = self.fire + self.earth + self.air + self.water
        pf = int(round(100*self.fire/total))
        pe = int(round(100*self.earth/total))
        pa = int(round(100*self.air/total))
        pw = int(round(100*self.water/total))
        out = &#39;&lt;g transform=&#34;translate(-30,79)&#34;&gt;\n&#39;
        out += &#39;&lt;text y=&#34;0&#34; style=&#34;fill:#ff6600; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;fire&#39;]+&#39;  &#39;+str(pf)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;text y=&#34;12&#34; style=&#34;fill:#6a2d04; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;earth&#39;]+&#39; &#39;+str(pe)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;text y=&#34;24&#34; style=&#34;fill:#6f76d1; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;air&#39;]+&#39;   &#39;+str(pa)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;text y=&#34;36&#34; style=&#34;fill:#630e73; font-size: 10px;&#34;&gt;&#39; + \
            self.language_settings[&#39;water&#39;]+&#39; &#39;+str(pw)+&#39;%&lt;/text&gt;\n&#39;
        out += &#39;&lt;/g&gt;\n&#39;
        return out

    def makePlanetGrid(self):
        out = &#39;&lt;g transform=&#34;translate(500,-20)&#34;&gt;&#39;

        # loop over all planets
        li = 10
        offset = 0

        out += &#39;&lt;g transform=&#34;translate(140, -15)&#34;&gt;&#39;
        out += \
            f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.language_settings[&#34;planets_and_house&#34;]} {self.name}:&lt;/text&gt;&#39;
        out += &#39;&lt;/g&gt;\n&#39;

        for i in range(len(self.planets_settings)):

            # Guarda qui !!
            if i == 27:
                li = 10
                offset = -120
            if self.planets_settings[i][&#39;visible&#39;] == 1:
                # start of line
                out += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (offset, li)
                # planet text
                out += f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 10px;&#34;&gt;{self.language_settings[&#34;planets&#34;][self.planets_settings[i][&#34;label&#34;]]}&lt;/text&gt;&#39;
                # planet symbol
                out += \
                    &#39;&lt;g transform=&#34;translate(5,-8)&#34;&gt;&lt;use transform=&#34;scale(0.4)&#34; xlink:href=&#34;#&#39; + \
                    self.planets_settings[i][&#39;name&#39;]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                # planet degree
                out += &#39;&lt;text text-anchor=&#34;start&#34; x=&#34;19&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.planets_degree[i]))
                # zodiac
                out += &#39;&lt;g transform=&#34;translate(60,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                    self.zodiac[self.planets_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                # planet retrograde
                if self.planets_retrograde[i]:
                    out += \
                        &#39;&lt;g transform=&#34;translate(74,-6)&#34;&gt;&lt;use transform=&#34;scale(.5)&#34; xlink:href=&#34;#retrograde&#34; /&gt;&lt;/g&gt;&#39;

                # end of line
                out += &#39;&lt;/g&gt;\n&#39;
                # offset between lines
                li = li + 14

        # ----------

        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

            if self.type == &#34;Transit&#34;:
                out += &#39;&lt;g transform=&#34;translate(320, -15)&#34;&gt;&#39;
                out += \
                    f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.t_name}:&lt;/text&gt;&#39;
            else:
                out += &#39;&lt;g transform=&#34;translate(380, -15)&#34;&gt;&#39;
                out += \
                    f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.language_settings[&#34;planets_and_house&#34;]} {self.t_user.name}:&lt;/text&gt;&#39;
            out += &#39;&lt;/g&gt;\n&#39;

            t_li = 10
            t_offset = 250

            for i in range(len(self.planets_settings)):
                if i == 27:
                    t_li = 10
                    t_offset = -120
                if self.planets_settings[i][&#39;visible&#39;] == 1:
                    # start of line
                    out += f&#39;&lt;g transform=&#34;translate({t_offset},{t_li})&#34;&gt;&#39;

                    # planet text
                    out += f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 10px;&#34;&gt;{self.language_settings[&#34;planets&#34;][self.planets_settings[i][&#34;label&#34;]]}&lt;/text&gt;&#39;
                    # planet symbol
                    out += f&#39;&lt;g transform=&#34;translate(5,-8)&#34;&gt;&lt;use transform=&#34;scale(0.4)&#34; xlink:href=&#34;# {self.planets_settings[i][&#34;name&#34;]}&#34; /&gt;&lt;/g&gt;&#39;
                    # planet degree
                    out += &#39;&lt;text text-anchor=&#34;start&#34; x=&#34;19&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                        self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.t_planets_degree[i]))
                    # zodiac
                    out += &#39;&lt;g transform=&#34;translate(60,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                        self.zodiac[self.t_planets_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                    # planet retrograde
                    if self.t_planets_retrograde[i]:
                        out += \
                            &#39;&lt;g transform=&#34;translate(74,-6)&#34;&gt;&lt;use transform=&#34;scale(.5)&#34; xlink:href=&#34;#retrograde&#34; /&gt;&lt;/g&gt;&#39;

                    # end of line
                    out += &#39;&lt;/g&gt;\n&#39;
                    # offset between lines
                    t_li = t_li + 14
        out += &#39;&lt;/g&gt;\n&#39;

        return out

    def makeHousesGrid(self):

        out = &#39;&lt;g transform=&#34;translate(600,-20)&#34;&gt;&#39;
        li = 10
        for i in range(12):
            if i &lt; 9:
                cusp = &#39;&amp;#160;&amp;#160;&#39;+str(i+1)
            else:
                cusp = str(i+1)
            out += &#39;&lt;g transform=&#34;translate(0,&#39;+str(li)+&#39;)&#34;&gt;&#39;
            out += &#39;&lt;text text-anchor=&#34;end&#34; x=&#34;40&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s %s:&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.language_settings[&#39;cusp&#39;], cusp)
            out += &#39;&lt;g transform=&#34;translate(40,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                self.zodiac[self.houses_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
            out += &#39;&lt;text x=&#34;53&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt; %s&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.houses_list[i][&#34;position&#34;]))
            out += &#39;&lt;/g&gt;\n&#39;
            li = li + 14
        out += &#39;&lt;/g&gt;\n&#39;

        # ----------

        if self.type == &#34;Composite&#34;:
            out += &#39;&lt;g transform=&#34;translate(840, -20)&#34;&gt;&#39;
            li = 10
            for i in range(12):
                if i &lt; 9:
                    cusp = &#39;&amp;#160;&amp;#160;&#39;+str(i+1)
                else:
                    cusp = str(i+1)
                out += &#39;&lt;g transform=&#34;translate(0,&#39;+str(li)+&#39;)&#34;&gt;&#39;
                out += &#39;&lt;text text-anchor=&#34;end&#34; x=&#34;40&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s %s:&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.language_settings[&#39;cusp&#39;], cusp)
                out += &#39;&lt;g transform=&#34;translate(40,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                    self.zodiac[self.t_houses_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                out += &#39;&lt;text x=&#34;53&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt; %s&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.t_houses_list[i][&#34;position&#34;]))
                out += &#39;&lt;/g&gt;\n&#39;
                li = li + 14
            out += &#39;&lt;/g&gt;\n&#39;

        return out

    def set_output_directory(self, dir_path):
        &#34;&#34;&#34;
        Sets the output direcotry and returns it&#39;s path.
        &#34;&#34;&#34;
        self.output_directory = Path(dir_path)
        dir_string = f&#34;Output direcotry set to: {self.output_directory}&#34;
        return (print(dir_string))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.dec2deg"><code class="name flex">
<span>def <span class="ident">dec2deg</span></span>(<span>self, dec, type='3')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dec2deg(self, dec, type=&#34;3&#34;):
    dec = float(dec)
    a = int(dec)
    a_new = (dec-float(a)) * 60.0
    b_rounded = int(round(a_new))
    b = int(a_new)
    c = int(round((a_new-float(b))*60.0))
    if type == &#34;3&#34;:
        out = &#39;%(#1)02d&amp;#176;%(#2)02d&amp;#39;%(#3)02d&amp;#34;&#39; % {
            &#39;#1&#39;: a, &#39;#2&#39;: b, &#39;#3&#39;: c}
    elif type == &#34;2&#34;:
        out = &#39;%(#1)02d&amp;#176;%(#2)02d&amp;#39;&#39; % {&#39;#1&#39;: a, &#39;#2&#39;: b_rounded}
    elif type == &#34;1&#34;:
        out = &#39;%(#1)02d&amp;#176;&#39; % {&#39;#1&#39;: a}
    return str(out)</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decHour"><code class="name flex">
<span>def <span class="ident">decHour</span></span>(<span>self, input)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decHour(self, input):
    hours = int(input)
    mands = (input-hours)*60.0
    mands = round(mands, 5)
    minutes = int(mands)
    seconds = int(round((mands-minutes)*60))
    return [hours, minutes, seconds]</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decHourJoin"><code class="name flex">
<span>def <span class="ident">decHourJoin</span></span>(<span>self, inH, inM, inS)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decHourJoin(self, inH, inM, inS):
    dh = float(inH)
    dm = float(inM)/60
    ds = float(inS)/3600
    output = dh + dm + ds
    return output</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decTzStr"><code class="name flex">
<span>def <span class="ident">decTzStr</span></span>(<span>self, tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decTzStr(self, tz):
    if tz &gt; 0:
        h = int(tz)
        m = int((float(tz)-float(h))*float(60))
        return &#34; [+%(#1)02d:%(#2)02d]&#34; % {&#39;#1&#39;: h, &#39;#2&#39;: m}
    else:
        h = int(tz)
        m = int((float(tz)-float(h))*float(60))/-1
        return &#34; [-%(#1)02d:%(#2)02d]&#34; % {&#39;#1&#39;: h/-1, &#39;#2&#39;: m}</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeDiff"><code class="name flex">
<span>def <span class="ident">degreeDiff</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def degreeDiff(self, a, b):
    out = float()
    if a &gt; b:
        out = a - b
    if a &lt; b:
        out = b-a
    if out &gt; 180.0:
        out = 360.0-out
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeRing"><code class="name flex">
<span>def <span class="ident">degreeRing</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def degreeRing(self, r):
    out = &#39;&#39;
    for i in range(72):
        offset = float(i*5) - self.houses_degree_ut[6]
        if offset &lt; 0:
            offset = offset + 360.0
        elif offset &gt; 360:
            offset = offset - 360.0
        x1 = self.sliceToX(0, r-self.c1, offset) + self.c1
        y1 = self.sliceToY(0, r-self.c1, offset) + self.c1
        x2 = self.sliceToX(0, r+2-self.c1, offset) - 2 + self.c1
        y2 = self.sliceToY(0, r+2-self.c1, offset) - 2 + self.c1
        out += &#39;&lt;line x1=&#34;%s&#34; y1=&#34;%s&#34; x2=&#34;%s&#34; y2=&#34;%s&#34; style=&#34;stroke: %s; stroke-width: 1px; stroke-opacity:.9;&#34;/&gt;\n&#39; % (
            x1, y1, x2, y2, self.colors_settings[&#39;paper_0&#39;])
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeTransitRing"><code class="name flex">
<span>def <span class="ident">degreeTransitRing</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def degreeTransitRing(self, r):
    out = &#39;&#39;
    for i in range(72):
        offset = float(i*5) - self.houses_degree_ut[6]
        if offset &lt; 0:
            offset = offset + 360.0
        elif offset &gt; 360:
            offset = offset - 360.0
        x1 = self.sliceToX(0, r, offset)
        y1 = self.sliceToY(0, r, offset)
        x2 = self.sliceToX(0, r+2, offset) - 2
        y2 = self.sliceToY(0, r+2, offset) - 2
        out += &#39;&lt;line x1=&#34;%s&#34; y1=&#34;%s&#34; x2=&#34;%s&#34; y2=&#34;%s&#34; style=&#34;stroke: #F00; stroke-width: 1px; stroke-opacity:.9;&#34;/&gt;\n&#39; % (
            x1, y1, x2, y2)
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.drawAspect"><code class="name flex">
<span>def <span class="ident">drawAspect</span></span>(<span>self, r, ar, degA, degB, color)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawAspect(self, r, ar, degA, degB, color):
    offset = (int(self.houses_degree_ut[6]) / -1) + int(degA)
    x1 = self.sliceToX(0, ar, offset) + (r-ar)
    y1 = self.sliceToY(0, ar, offset) + (r-ar)
    offset = (int(self.houses_degree_ut[6]) / -1) + int(degB)
    x2 = self.sliceToX(0, ar, offset) + (r-ar)
    y2 = self.sliceToY(0, ar, offset) + (r-ar)
    out = &#39;            &lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
        y2)+&#39;&#34; style=&#34;stroke: &#39;+color+&#39;; stroke-width: 1; stroke-opacity: .9;&#34;/&gt;\n&#39;
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.lat2str"><code class="name flex">
<span>def <span class="ident">lat2str</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lat2str(self, coord):
    sign = self.language_settings[&#34;north&#34;]
    if coord &lt; 0.0:
        sign = self.language_settings[&#34;south&#34;]
        coord = abs(coord)
    deg = int(coord)
    min = int((float(coord) - deg) * 60)
    sec = int(round(float(((float(coord) - deg) * 60) - min) * 60.0))
    return &#34;%s°%s&#39;%s\&#34; %s&#34; % (deg, min, sec, sign)</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.lon2str"><code class="name flex">
<span>def <span class="ident">lon2str</span></span>(<span>self, coord)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lon2str(self, coord):
    sign = self.language_settings[&#34;east&#34;]
    if coord &lt; 0.0:
        sign = self.language_settings[&#34;west&#34;]
        coord = abs(coord)
    deg = int(coord)
    min = int((float(coord) - deg) * 60)
    sec = int(round(float(((float(coord) - deg) * 60) - min) * 60.0))
    return &#34;%s°%s&#39;%s\&#34; %s&#34; % (deg, min, sec, sign)</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectGrid"><code class="name flex">
<span>def <span class="ident">makeAspectGrid</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeAspectGrid(self, r):

    out = &#34;&#34;
    style = &#39;stroke:%s; stroke-width: 1px; stroke-opacity:.6; fill:none&#39; % (
        self.colors_settings[&#39;paper_0&#39;])
    xindent = 380
    yindent = 468
    box = 14
    revr = list(range(len(self.planets_settings)))
    revr.reverse()
    counter = 0
    for a in revr:
        counter += 1
        if self.planets_settings[a][&#39;visible&#39;] == 1:
            out += &#39;&lt;rect x=&#34;&#39;+str(xindent)+&#39;&#34; y=&#34;&#39;+str(yindent)+&#39;&#34; width=&#34;&#39;+str(
                box)+&#39;&#34; height=&#34;&#39;+str(box)+&#39;&#34; style=&#34;&#39;+style+&#39;&#34;/&gt;\n&#39;
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;&#39;+str((xindent+2)*2.5)+&#39;&#34; y=&#34;&#39;+str(
                (yindent+1)*2.5)+&#39;&#34; xlink:href=&#34;#&#39;+self.planets_settings[a][&#39;name&#39;]+&#39;&#34; /&gt;\n&#39;
            xindent = xindent + box
            yindent = yindent - box
            revr2 = list(range(a))
            revr2.reverse()
            xorb = xindent
            yorb = yindent + box
            for b in revr2:
                if self.planets_settings[b][&#39;visible&#39;] == 1:
                    out += &#39;&lt;rect x=&#34;&#39;+str(xorb)+&#39;&#34; y=&#34;&#39;+str(yorb)+&#39;&#34; width=&#34;&#39;+str(
                        box)+&#39;&#34; height=&#34;&#39;+str(box)+&#39;&#34; style=&#34;&#39;+style+&#39;&#34;/&gt;\n&#39;
                    xorb = xorb+box
                    for element in self.aspects_list:
                        if (element[&#39;p1&#39;] == a and element[&#39;p2&#39;] == b) or (element[&#39;p1&#39;] == b and element[&#39;p2&#39;] == a):
                            out += &#39;&lt;use  x=&#34;&#39;+str(xorb-box+1)+&#39;&#34; y=&#34;&#39;+str(
                                yorb+1)+&#39;&#34; xlink:href=&#34;#orb&#39;+str(element[&#39;aspect_degrees&#39;])+&#39;&#34; /&gt;\n&#39;

    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectTransitGrid"><code class="name flex">
<span>def <span class="ident">makeAspectTransitGrid</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeAspectTransitGrid(self, r):
    out = &#39;&lt;g transform=&#34;translate(500,310)&#34;&gt;&#39;
    out += &#39;&lt;text y=&#34;-15&#34; x=&#34;0&#34; style=&#34;fill:%s; font-size: 14px;&#34;&gt;%s&lt;/text&gt;\n&#39; % (
        self.colors_settings[&#39;paper_0&#39;], (f&#34;{self.language_settings[&#39;aspects&#39;]}:&#34;))
    line = 0
    nl = 0
    for i in range(len(self.aspects_list)):
        if i == 12:
            nl = 100
            # if len(self.aspects_list) &gt; 24:
            #     line = -1 * ( len(self.aspects_list) - 24) * 14
            # else:
            #     line = 0

            # temporary:
            line = 0

        if i == 24:
            nl = 200
            # if len(self.aspects_list) &gt; 36:
            #     line = -1 * ( len(self.aspects_list) - 36) * 14
            # else:
            #     line = 0
            line = 0

        if i == 36:
            nl = 300
            if len(self.aspects_list) &gt; 48:
                line = -1 * (len(self.aspects_list) - 48) * 14
            else:
                line = 0
        out += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (nl, line)
        # first planet symbol
        out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;3&#34; xlink:href=&#34;#%s&#34; /&gt;\n&#39; % (
            self.planets_settings[self.aspects_list[i][&#39;p1&#39;]][&#39;name&#39;])
        # aspect symbol
        out += &#39;&lt;use  x=&#34;15&#34; y=&#34;0&#34; xlink:href=&#34;#orb%s&#34; /&gt;\n&#39; % (
            self.aspects_settings[self.aspects_list[i][&#39;aid&#39;]][&#39;degree&#39;])
        # second planet symbol
        out += &#39;&lt;g transform=&#34;translate(30,0)&#34;&gt;&#39;
        out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;3&#34; xlink:href=&#34;#%s&#34; /&gt;\n&#39; % (
            self.planets_settings[self.aspects_list[i][&#39;p2&#39;]][&#39;name&#39;])
        out += &#39;&lt;/g&gt;&#39;
        # difference in degrees
        out += &#39;&lt;text y=&#34;8&#34; x=&#34;45&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
            self.colors_settings[&#39;paper_0&#39;],
            self.dec2deg(self.aspects_list[i][&#39;orbit&#39;]))
        # line
        out += &#39;&lt;/g&gt;&#39;
        line = line + 14
    out += &#39;&lt;/g&gt;&#39;
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspects"><code class="name flex">
<span>def <span class="ident">makeAspects</span></span>(<span>self, r, ar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeAspects(self, r, ar):
    out = &#34;&#34;
    for element in self.aspects_list:
        out += self.drawAspect(r, ar, element[&#39;p1_abs_pos&#39;], element[&#39;p2_abs_pos&#39;],
                               self.colors_settings[f&#34;aspect_{element[&#39;aspect_degrees&#39;]}&#34;])

    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectsTransit"><code class="name flex">
<span>def <span class="ident">makeAspectsTransit</span></span>(<span>self, r, ar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeAspectsTransit(self, r, ar):
    out = &#34;&#34;

    self.aspects_list = kr.utilities.CompositeAspects(
        self.user, self.t_user, new_settings_file=self.settings_file
        ).get_aspects()

    for element in self.aspects_list:
        out += self.drawAspect(r, ar, element[&#39;p1_abs_pos&#39;], element[&#39;p2_abs_pos&#39;],
                               self.colors_settings[f&#34;aspect_{element[&#39;aspect_degrees&#39;]}&#34;])

    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeElements"><code class="name flex">
<span>def <span class="ident">makeElements</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeElements(self, r):
    total = self.fire + self.earth + self.air + self.water
    pf = int(round(100*self.fire/total))
    pe = int(round(100*self.earth/total))
    pa = int(round(100*self.air/total))
    pw = int(round(100*self.water/total))
    out = &#39;&lt;g transform=&#34;translate(-30,79)&#34;&gt;\n&#39;
    out += &#39;&lt;text y=&#34;0&#34; style=&#34;fill:#ff6600; font-size: 10px;&#34;&gt;&#39; + \
        self.language_settings[&#39;fire&#39;]+&#39;  &#39;+str(pf)+&#39;%&lt;/text&gt;\n&#39;
    out += &#39;&lt;text y=&#34;12&#34; style=&#34;fill:#6a2d04; font-size: 10px;&#34;&gt;&#39; + \
        self.language_settings[&#39;earth&#39;]+&#39; &#39;+str(pe)+&#39;%&lt;/text&gt;\n&#39;
    out += &#39;&lt;text y=&#34;24&#34; style=&#34;fill:#6f76d1; font-size: 10px;&#34;&gt;&#39; + \
        self.language_settings[&#39;air&#39;]+&#39;   &#39;+str(pa)+&#39;%&lt;/text&gt;\n&#39;
    out += &#39;&lt;text y=&#34;36&#34; style=&#34;fill:#630e73; font-size: 10px;&#34;&gt;&#39; + \
        self.language_settings[&#39;water&#39;]+&#39; &#39;+str(pw)+&#39;%&lt;/text&gt;\n&#39;
    out += &#39;&lt;/g&gt;\n&#39;
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeHouses"><code class="name flex">
<span>def <span class="ident">makeHouses</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeHouses(self, r):
    path = &#34;&#34;

    xr = 12
    for i in range(xr):
        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 160
            roff = 72
            t_roff = 36
        else:
            dropin = self.c3
            roff = self.c1

        # offset is negative desc houses_degree_ut[6]
        offset = (
            int(self.houses_degree_ut[int(xr/2)]) / -1) + int(self.houses_degree_ut[i])
        x1 = self.sliceToX(0, (r-dropin), offset) + dropin
        y1 = self.sliceToY(0, (r-dropin), offset) + dropin
        x2 = self.sliceToX(0, r-roff, offset) + roff
        y2 = self.sliceToY(0, r-roff, offset) + roff

        if i &lt; (xr-1):
            text_offset = offset + \
                int(self.degreeDiff(self.houses_degree_ut[(
                    i+1)], self.houses_degree_ut[i]) / 2)
        else:
            text_offset = offset + \
                int(self.degreeDiff(
                    self.houses_degree_ut[0], self.houses_degree_ut[(xr-1)]) / 2)

        # mc, asc, dsc, ic
        if i == 0:
            linecolor = self.planets_settings[12][&#39;color&#39;]
        elif i == 9:
            linecolor = self.planets_settings[13][&#39;color&#39;]
        elif i == 6:
            linecolor = self.planets_settings[14][&#39;color&#39;]
        elif i == 3:
            linecolor = self.planets_settings[15][&#39;color&#39;]
        else:
            linecolor = self.colors_settings[&#39;houses_radix_line&#39;]

        # Transit houses lines.
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

            # Degrees for point zero.

            zeropoint = 360 - self.houses_degree_ut[6]
            t_offset = zeropoint + self.t_houses_degree_ut[i]
            if t_offset &gt; 360:
                t_offset = t_offset - 360
            t_x1 = self.sliceToX(0, (r-t_roff), t_offset) + t_roff
            t_y1 = self.sliceToY(0, (r-t_roff), t_offset) + t_roff
            t_x2 = self.sliceToX(0, r, t_offset)
            t_y2 = self.sliceToY(0, r, t_offset)
            if i &lt; 11:
                t_text_offset = t_offset + \
                    int(self.degreeDiff(self.t_houses_degree_ut[(
                        i+1)], self.t_houses_degree_ut[i]) / 2)
            else:
                t_text_offset = t_offset + \
                    int(self.degreeDiff(
                        self.t_houses_degree_ut[0], self.t_houses_degree_ut[11]) / 2)
            # linecolor
            if i == 0 or i == 9 or i == 6 or i == 3:
                t_linecolor = linecolor
            else:
                t_linecolor = self.colors_settings[&#39;houses_transit_line&#39;]
            xtext = self.sliceToX(0, (r-8), t_text_offset) + 8
            ytext = self.sliceToY(0, (r-8), t_text_offset) + 8

            if self.type == &#34;Transit&#34;:
                path = path + &#39;&lt;text style=&#34;fill: #00f; fill-opacity: 0; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                    str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                    &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;
                path = path + &#39;&lt;line x1=&#34;&#39;+str(t_x1)+&#39;&#34; y1=&#34;&#39;+str(t_y1)+&#39;&#34; x2=&#34;&#39;+str(t_x2)+&#39;&#34; y2=&#34;&#39;+str(
                    t_y2)+&#39;&#34; style=&#34;stroke: &#39;+t_linecolor+&#39;; stroke-width: 2px; stroke-opacity:0;&#34;/&gt;\n&#39;

            else:
                path = path + &#39;&lt;text style=&#34;fill: #00f; fill-opacity: .4; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
                    str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
                    &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;
                path = path + &#39;&lt;line x1=&#34;&#39;+str(t_x1)+&#39;&#34; y1=&#34;&#39;+str(t_y1)+&#39;&#34; x2=&#34;&#39;+str(t_x2)+&#39;&#34; y2=&#34;&#39;+str(
                    t_y2)+&#39;&#34; style=&#34;stroke: &#39;+t_linecolor+&#39;; stroke-width: 2px; stroke-opacity:.3;&#34;/&gt;\n&#39;

        # if transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 84

        dropin = 48

        xtext = self.sliceToX(
            0, (r-dropin), text_offset) + dropin  # was 132
        ytext = self.sliceToY(
            0, (r-dropin), text_offset) + dropin  # was 132
        path = path + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
            y2)+&#39;&#34; style=&#34;stroke: &#39;+linecolor+&#39;; stroke-width: 2px; stroke-dasharray:3,2; stroke-opacity:.4;&#34;/&gt;\n&#39;
        path = path + &#39;&lt;text style=&#34;fill: #f00; fill-opacity: .6; font-size: 14px&#34;&gt;&lt;tspan x=&#34;&#39; + \
            str(xtext-3)+&#39;&#34; y=&#34;&#39;+str(ytext+3) + \
            &#39;&#34;&gt;&#39;+str(i+1)+&#39;&lt;/tspan&gt;&lt;/text&gt;\n&#39;

    return path</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeHousesGrid"><code class="name flex">
<span>def <span class="ident">makeHousesGrid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeHousesGrid(self):

    out = &#39;&lt;g transform=&#34;translate(600,-20)&#34;&gt;&#39;
    li = 10
    for i in range(12):
        if i &lt; 9:
            cusp = &#39;&amp;#160;&amp;#160;&#39;+str(i+1)
        else:
            cusp = str(i+1)
        out += &#39;&lt;g transform=&#34;translate(0,&#39;+str(li)+&#39;)&#34;&gt;&#39;
        out += &#39;&lt;text text-anchor=&#34;end&#34; x=&#34;40&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s %s:&lt;/text&gt;&#39; % (
            self.colors_settings[&#39;paper_0&#39;], self.language_settings[&#39;cusp&#39;], cusp)
        out += &#39;&lt;g transform=&#34;translate(40,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
            self.zodiac[self.houses_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
        out += &#39;&lt;text x=&#34;53&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt; %s&lt;/text&gt;&#39; % (
            self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.houses_list[i][&#34;position&#34;]))
        out += &#39;&lt;/g&gt;\n&#39;
        li = li + 14
    out += &#39;&lt;/g&gt;\n&#39;

    # ----------

    if self.type == &#34;Composite&#34;:
        out += &#39;&lt;g transform=&#34;translate(840, -20)&#34;&gt;&#39;
        li = 10
        for i in range(12):
            if i &lt; 9:
                cusp = &#39;&amp;#160;&amp;#160;&#39;+str(i+1)
            else:
                cusp = str(i+1)
            out += &#39;&lt;g transform=&#34;translate(0,&#39;+str(li)+&#39;)&#34;&gt;&#39;
            out += &#39;&lt;text text-anchor=&#34;end&#34; x=&#34;40&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s %s:&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.language_settings[&#39;cusp&#39;], cusp)
            out += &#39;&lt;g transform=&#34;translate(40,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                self.zodiac[self.t_houses_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
            out += &#39;&lt;text x=&#34;53&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt; %s&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.t_houses_list[i][&#34;position&#34;]))
            out += &#39;&lt;/g&gt;\n&#39;
            li = li + 14
        out += &#39;&lt;/g&gt;\n&#39;

    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePatterns"><code class="name flex">
<span>def <span class="ident">makePatterns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>Stellium: At least four planets linked together in a series of continuous conjunctions.</li>
<li>Grand trine: Three trine aspects together.</li>
<li>Grand cross: Two pairs of opposing planets squared to each other.</li>
<li>T-Square: Two planets in opposition squared to a third.</li>
<li>Yod: Two qunicunxes together joined by a sextile.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makePatterns(self):
    &#34;&#34;&#34;
    * Stellium: At least four planets linked together in a series of continuous conjunctions.
    * Grand trine: Three trine aspects together.
    * Grand cross: Two pairs of opposing planets squared to each other.
    * T-Square: Two planets in opposition squared to a third.
    * Yod: Two qunicunxes together joined by a sextile.
    &#34;&#34;&#34;
    conj = {}  # 0
    opp = {}  # 10
    sq = {}  # 5
    tr = {}  # 6
    qc = {}  # 9
    sext = {}  # 3
    for i in range(len(self.planets_settings)):
        a = self.planets_degree_ut[i]
        qc[i] = {}
        sext[i] = {}
        opp[i] = {}
        sq[i] = {}
        tr[i] = {}
        conj[i] = {}
        # skip some points
        n = self.planets_settings[i][&#39;name&#39;]
        if n == &#39;earth&#39; or n == &#39;True_Node&#39; or n == &#39;osc. apogee&#39; or n == &#39;intp. apogee&#39; or n == &#39;intp. perigee&#39;:
            continue
        if n == &#39;Dsc&#39; or n == &#39;Ic&#39;:
            continue
        for j in range(len(self.planets_settings)):
            # skip some points
            n = self.planets_settings[j][&#39;name&#39;]
            if n == &#39;earth&#39; or n == &#39;True_Node&#39; or n == &#39;osc. apogee&#39; or n == &#39;intp. apogee&#39; or n == &#39;intp. perigee&#39;:
                continue
            if n == &#39;Dsc&#39; or n == &#39;Ic&#39;:
                continue
            b = self.planets_degree_ut[j]
            delta = float(self.degreeDiff(a, b))
            # check for opposition
            xa = float(self.aspects_settings[10][&#39;degree&#39;]) - \
                float(self.aspects_settings[10][&#39;orb&#39;])
            xb = float(self.aspects_settings[10][&#39;degree&#39;]) + \
                float(self.aspects_settings[10][&#39;orb&#39;])
            if(xa &lt;= delta &lt;= xb):
                opp[i][j] = True
            # check for conjunction
            xa = float(self.aspects_settings[0][&#39;degree&#39;]) - \
                float(self.aspects_settings[0][&#39;orb&#39;])
            xb = float(self.aspects_settings[0][&#39;degree&#39;]) + \
                float(self.aspects_settings[0][&#39;orb&#39;])
            if(xa &lt;= delta &lt;= xb):
                conj[i][j] = True
            # check for squares
            xa = float(self.aspects_settings[5][&#39;degree&#39;]) - \
                float(self.aspects_settings[5][&#39;orb&#39;])
            xb = float(self.aspects_settings[5][&#39;degree&#39;]) + \
                float(self.aspects_settings[5][&#39;orb&#39;])
            if(xa &lt;= delta &lt;= xb):
                sq[i][j] = True
            # check for qunicunxes
            xa = float(self.aspects_settings[9][&#39;degree&#39;]) - \
                float(self.aspects_settings[9][&#39;orb&#39;])
            xb = float(self.aspects_settings[9][&#39;degree&#39;]) + \
                float(self.aspects_settings[9][&#39;orb&#39;])
            if(xa &lt;= delta &lt;= xb):
                qc[i][j] = True
            # check for sextiles
            xa = float(self.aspects_settings[3][&#39;degree&#39;]) - \
                float(self.aspects_settings[3][&#39;orb&#39;])
            xb = float(self.aspects_settings[3][&#39;degree&#39;]) + \
                float(self.aspects_settings[3][&#39;orb&#39;])
            if(xa &lt;= delta &lt;= xb):
                sext[i][j] = True

    yot = {}
    # check for double qunicunxes
    for k, v in qc.items():
        if len(qc[k]) &gt;= 2:
            # check for sextile
            for l, w in qc[k].items():
                for m, x in qc[k].items():
                    if m in sext[l]:
                        if l &gt; m:
                            yot[&#39;%s,%s,%s&#39; % (k, m, l)] = [k, m, l]
                        else:
                            yot[&#39;%s,%s,%s&#39; % (k, l, m)] = [k, l, m]
    tsquare = {}
    # check for opposition
    for k, v in opp.items():
        if len(opp[k]) &gt;= 1:
            # check for square
            for l, w in opp[k].items():
                for a, b in sq.items():
                    if k in sq[a] and l in sq[a]:
                        # print &#39;got tsquare %s %s %s&#39; % (a,k,l)
                        if k &gt; l:
                            tsquare[&#39;%s,%s,%s&#39; % (a, l, k)] = &#39;%s =&gt; %s, %s&#39; % (
                                self.planets_settings[a][&#39;label&#39;], self.planets_settings[l][&#39;label&#39;], self.planets_settings[k][&#39;label&#39;])
                        else:
                            tsquare[&#39;%s,%s,%s&#39; % (a, k, l)] = &#39;%s =&gt; %s, %s&#39; % (
                                self.planets_settings[a][&#39;label&#39;], self.planets_settings[k][&#39;label&#39;], self.planets_settings[l][&#39;label&#39;])
    stellium = {}
    # check for 4 continuous conjunctions
    for k, v in conj.items():
        if len(conj[k]) &gt;= 1:
            # first conjunction
            for l, m in conj[k].items():
                if len(conj[l]) &gt;= 1:
                    for n, o in conj[l].items():
                        # skip 1st conj
                        if n == k:
                            continue
                        if len(conj[n]) &gt;= 1:
                            # third conjunction
                            for p, q in conj[n].items():
                                # skip first and second conj
                                if p == k or p == n:
                                    continue
                                if len(conj[p]) &gt;= 1:
                                    # fourth conjunction
                                    for r, s in conj[p].items():
                                        # skip conj 1,2,3
                                        if r == k or r == n or r == p:
                                            continue

                                        l = [k, n, p, r]
                                        l.sort()
                                        stellium[&#39;%s %s %s %s&#39; % (l[0], l[1], l[2], l[3])] = &#39;%s %s %s %s&#39; % (
                                            self.planets_settings[l[0]
                                                                  ][&#39;label&#39;], self.planets_settings[l[1]][&#39;label&#39;],
                                            self.planets_settings[l[2]][&#39;label&#39;], self.planets_settings[l[3]][&#39;label&#39;])
    # print yots
    out = &#39;&lt;g transform=&#34;translate(-30,380)&#34;&gt;&#39;
    if len(yot) &gt;= 1:
        y = 0
        for k, v in yot.items():
            out += &#39;&lt;text y=&#34;%s&#34; style=&#34;fill:%s; font-size: 12px;&#34;&gt;%s&lt;/text&gt;\n&#39; % (
                y, self.colors_settings[&#39;paper_0&#39;], (&#34;Yot&#34;))

            # first planet symbol
            out += &#39;&lt;g transform=&#34;translate(20,%s)&#34;&gt;&#39; % (y)
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                self.planets_settings[yot[k][0]][&#39;name&#39;])

            # second planet symbol
            out += &#39;&lt;g transform=&#34;translate(30,%s)&#34;&gt;&#39; % (y)
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                self.planets_settings[yot[k][1]][&#39;name&#39;])

            # third planet symbol
            out += &#39;&lt;g transform=&#34;translate(40,%s)&#34;&gt;&#39; % (y)
            out += &#39;&lt;use transform=&#34;scale(0.4)&#34; x=&#34;0&#34; y=&#34;-20&#34; xlink:href=&#34;#%s&#34; /&gt;&lt;/g&gt;\n&#39; % (
                self.planets_settings[yot[k][2]][&#39;name&#39;])

            y = y+14
    # finalize
    out += &#39;&lt;/g&gt;&#39;
    # return out
    return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePlanetGrid"><code class="name flex">
<span>def <span class="ident">makePlanetGrid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makePlanetGrid(self):
    out = &#39;&lt;g transform=&#34;translate(500,-20)&#34;&gt;&#39;

    # loop over all planets
    li = 10
    offset = 0

    out += &#39;&lt;g transform=&#34;translate(140, -15)&#34;&gt;&#39;
    out += \
        f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.language_settings[&#34;planets_and_house&#34;]} {self.name}:&lt;/text&gt;&#39;
    out += &#39;&lt;/g&gt;\n&#39;

    for i in range(len(self.planets_settings)):

        # Guarda qui !!
        if i == 27:
            li = 10
            offset = -120
        if self.planets_settings[i][&#39;visible&#39;] == 1:
            # start of line
            out += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (offset, li)
            # planet text
            out += f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 10px;&#34;&gt;{self.language_settings[&#34;planets&#34;][self.planets_settings[i][&#34;label&#34;]]}&lt;/text&gt;&#39;
            # planet symbol
            out += \
                &#39;&lt;g transform=&#34;translate(5,-8)&#34;&gt;&lt;use transform=&#34;scale(0.4)&#34; xlink:href=&#34;#&#39; + \
                self.planets_settings[i][&#39;name&#39;]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
            # planet degree
            out += &#39;&lt;text text-anchor=&#34;start&#34; x=&#34;19&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.planets_degree[i]))
            # zodiac
            out += &#39;&lt;g transform=&#34;translate(60,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                self.zodiac[self.planets_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
            # planet retrograde
            if self.planets_retrograde[i]:
                out += \
                    &#39;&lt;g transform=&#34;translate(74,-6)&#34;&gt;&lt;use transform=&#34;scale(.5)&#34; xlink:href=&#34;#retrograde&#34; /&gt;&lt;/g&gt;&#39;

            # end of line
            out += &#39;&lt;/g&gt;\n&#39;
            # offset between lines
            li = li + 14

    # ----------

    if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:

        if self.type == &#34;Transit&#34;:
            out += &#39;&lt;g transform=&#34;translate(320, -15)&#34;&gt;&#39;
            out += \
                f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.t_name}:&lt;/text&gt;&#39;
        else:
            out += &#39;&lt;g transform=&#34;translate(380, -15)&#34;&gt;&#39;
            out += \
                f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 14px;&#34;&gt;{self.language_settings[&#34;planets_and_house&#34;]} {self.t_user.name}:&lt;/text&gt;&#39;
        out += &#39;&lt;/g&gt;\n&#39;

        t_li = 10
        t_offset = 250

        for i in range(len(self.planets_settings)):
            if i == 27:
                t_li = 10
                t_offset = -120
            if self.planets_settings[i][&#39;visible&#39;] == 1:
                # start of line
                out += f&#39;&lt;g transform=&#34;translate({t_offset},{t_li})&#34;&gt;&#39;

                # planet text
                out += f&#39;&lt;text text-anchor=&#34;end&#34; style=&#34;fill:{self.colors_settings[&#34;paper_0&#34;]}; font-size: 10px;&#34;&gt;{self.language_settings[&#34;planets&#34;][self.planets_settings[i][&#34;label&#34;]]}&lt;/text&gt;&#39;
                # planet symbol
                out += f&#39;&lt;g transform=&#34;translate(5,-8)&#34;&gt;&lt;use transform=&#34;scale(0.4)&#34; xlink:href=&#34;# {self.planets_settings[i][&#34;name&#34;]}&#34; /&gt;&lt;/g&gt;&#39;
                # planet degree
                out += &#39;&lt;text text-anchor=&#34;start&#34; x=&#34;19&#34; style=&#34;fill:%s; font-size: 10px;&#34;&gt;%s&lt;/text&gt;&#39; % (
                    self.colors_settings[&#39;paper_0&#39;], self.dec2deg(self.t_planets_degree[i]))
                # zodiac
                out += &#39;&lt;g transform=&#34;translate(60,-8)&#34;&gt;&lt;use transform=&#34;scale(0.3)&#34; xlink:href=&#34;#&#39; + \
                    self.zodiac[self.t_planets_sign[i]]+&#39;&#34; /&gt;&lt;/g&gt;&#39;
                # planet retrograde
                if self.t_planets_retrograde[i]:
                    out += \
                        &#39;&lt;g transform=&#34;translate(74,-6)&#34;&gt;&lt;use transform=&#34;scale(.5)&#34; xlink:href=&#34;#retrograde&#34; /&gt;&lt;/g&gt;&#39;

                # end of line
                out += &#39;&lt;/g&gt;\n&#39;
                # offset between lines
                t_li = t_li + 14
    out += &#39;&lt;/g&gt;\n&#39;

    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePlanets"><code class="name flex">
<span>def <span class="ident">makePlanets</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makePlanets(self, r):

    planets_degut = {}

    diff = range(len(self.planets_settings))
    for i in range(len(self.planets_settings)):
        if self.planets_settings[i][&#39;visible&#39;] == 1:
            # list of planets sorted by degree
            planets_degut[self.planets_degree_ut[i]] = i

        # element: get extra points if planet is in own zodiac
        pz = self.planets_settings[i][&#39;zodiac_relation&#39;]
        cz = self.planets_sign[i]
        extrapoints = 0
        if pz != -1:
            for e in range(len(pz.split(&#39;,&#39;))):
                if int(pz.split(&#39;,&#39;)[e]) == int(cz):
                    extrapoints = 10

        # calculate element points for all planets
        ele = self.zodiac_element[self.planets_sign[i]]
        if ele == &#34;fire&#34;:
            self.fire = self.fire + \
                self.planets_settings[i][&#39;element_points&#39;] + extrapoints
        elif ele == &#34;earth&#34;:
            self.earth = self.earth + \
                self.planets_settings[i][&#39;element_points&#39;] + extrapoints
        elif ele == &#34;air&#34;:
            self.air = self.air + \
                self.planets_settings[i][&#39;element_points&#39;] + extrapoints
        elif ele == &#34;water&#34;:
            self.water = self.water + \
                self.planets_settings[i][&#39;element_points&#39;] + extrapoints

    output = &#34;&#34;
    keys = list(planets_degut.keys())
    keys.sort()
    switch = 0

    planets_degrouped = {}
    groups = []
    planets_by_pos = list(range(len(planets_degut)))
    planet_drange = 3.4
    # get groups closely together
    group_open = False
    for e in range(len(keys)):
        i = planets_degut[keys[e]]
        # get distances between planets
        if e == 0:
            prev = self.planets_degree_ut[planets_degut[keys[-1]]]
            next = self.planets_degree_ut[planets_degut[keys[1]]]
        elif e == (len(keys)-1):
            prev = self.planets_degree_ut[planets_degut[keys[e-1]]]
            next = self.planets_degree_ut[planets_degut[keys[0]]]
        else:
            prev = self.planets_degree_ut[planets_degut[keys[e-1]]]
            next = self.planets_degree_ut[planets_degut[keys[e+1]]]
        diffa = self.degreeDiff(prev, self.planets_degree_ut[i])
        diffb = self.degreeDiff(next, self.planets_degree_ut[i])
        planets_by_pos[e] = [i, diffa, diffb]
        # print &#34;%s %s %s&#34; % (self.planets_settings[i][&#39;label&#39;],diffa,diffb)
        if (diffb &lt; planet_drange):
            if group_open:
                groups[-1].append([e, diffa, diffb,
                                  self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
            else:
                group_open = True
                groups.append([])
                groups[-1].append([e, diffa, diffb,
                                  self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
        else:
            if group_open:
                groups[-1].append([e, diffa, diffb,
                                  self.planets_settings[planets_degut[keys[e]]][&#34;label&#34;]])
            group_open = False

    def zero(x): return 0
    planets_delta = list(map(zero, range(len(self.planets_settings))))

    # print groups
    # print planets_by_pos
    for a in range(len(groups)):
        # Two grouped planets
        if len(groups[a]) == 2:
            next_to_a = groups[a][0][0]-1
            if groups[a][1][0] == (len(planets_by_pos)-1):
                next_to_b = 0
            else:
                next_to_b = groups[a][1][0]+1
            # if both planets have room
            if (groups[a][0][1] &gt; (2*planet_drange)) &amp; (groups[a][1][2] &gt; (2*planet_drange)):
                planets_delta[groups[a][0][0]] = - \
                    (planet_drange-groups[a][0][2])/2
                planets_delta[groups[a][1][0]] = + \
                    (planet_drange-groups[a][0][2])/2
            # if planet a has room
            elif (groups[a][0][1] &gt; (2*planet_drange)):
                planets_delta[groups[a][0][0]] = -planet_drange
            # if planet b has room
            elif (groups[a][1][2] &gt; (2*planet_drange)):
                planets_delta[groups[a][1][0]] = +planet_drange

            # if planets next to a and b have room move them
            elif (planets_by_pos[next_to_a][1] &gt; (2.4*planet_drange)) &amp; (planets_by_pos[next_to_b][2] &gt; (2.4*planet_drange)):
                planets_delta[(next_to_a)] = (
                    groups[a][0][1]-planet_drange*2)
                planets_delta[groups[a][0][0]] = -planet_drange*.5
                planets_delta[next_to_b] = - \
                    (groups[a][1][2]-planet_drange*2)
                planets_delta[groups[a][1][0]] = +planet_drange*.5

            # if planet next to a has room move them
            elif (planets_by_pos[next_to_a][1] &gt; (2*planet_drange)):
                planets_delta[(next_to_a)] = (
                    groups[a][0][1]-planet_drange*2.5)
                planets_delta[groups[a][0][0]] = -planet_drange*1.2

            # if planet next to b has room move them
            elif (planets_by_pos[next_to_b][2] &gt; (2*planet_drange)):
                planets_delta[next_to_b] = - \
                    (groups[a][1][2]-planet_drange*2.5)
                planets_delta[groups[a][1][0]] = +planet_drange*1.2

        # Three grouped planets or more
        xl = len(groups[a])
        if xl &gt;= 3:

            available = groups[a][0][1]
            for f in range(xl):
                available += groups[a][f][2]
            need = (3*planet_drange)+(1.2*(xl-1)*planet_drange)
            leftover = available - need
            xa = groups[a][0][1]
            xb = groups[a][(xl-1)][2]

            # center
            if (xa &gt; (need*.5)) &amp; (xb &gt; (need*.5)):
                startA = xa - (need*.5)
            # position relative to next planets
            else:
                startA = (leftover/(xa+xb))*xa
                startB = (leftover/(xa+xb))*xb

            if available &gt; need:
                planets_delta[groups[a][0][0]] = startA - \
                    groups[a][0][1]+(1.5*planet_drange)
                for f in range(xl-1):
                    planets_delta[groups[a][(
                        f+1)][0]] = 1.2*planet_drange+planets_delta[groups[a][f][0]]-groups[a][f][2]

    for e in range(len(keys)):
        i = planets_degut[keys[e]]

        # coordinates
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            if 22 &lt; i &lt; 27:
                rplanet = 76
            elif switch == 1:
                rplanet = 110
                switch = 0
            else:
                rplanet = 130
                switch = 1
        else:
            # if 22 &lt; i &lt; 27 it is asc,mc,dsc,ic (angles of chart)
            # put on special line (rplanet is range from outer ring)
            amin, bmin, cmin = 0, 0, 0

            if 22 &lt; i &lt; 27:
                rplanet = 40-cmin
            elif switch == 1:
                rplanet = 74-amin
                switch = 0
            else:
                rplanet = 94-bmin
                switch = 1

        rtext = 45

        offset = (int(self.houses_degree_ut[6]) / -1) + \
            int(self.planets_degree_ut[i]+planets_delta[e])
        trueoffset = (
            int(self.houses_degree_ut[6]) / -1) + int(self.planets_degree_ut[i])

        planet_x = self.sliceToX(0, (r-rplanet), offset) + rplanet
        planet_y = self.sliceToY(0, (r-rplanet), offset) + rplanet
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            scale = 0.8

        scale = 1
        # output planet
        output = output + &#39;&lt;g transform=&#34;translate(-&#39;+str(12*scale)+&#39;,-&#39;+str(12*scale)+&#39;)&#34;&gt;&lt;g transform=&#34;scale(&#39;+str(scale)+&#39;)&#34;&gt;&lt;use x=&#34;&#39; + str(
            planet_x*(1/scale)) + &#39;&#34; y=&#34;&#39; + str(planet_y*(1/scale)) + &#39;&#34; xlink:href=&#34;#&#39; + self.planets_settings[i][&#39;name&#39;] + &#39;&#34; /&gt;&lt;/g&gt;&lt;/g&gt;\n&#39;

    # make transit degut and display planets
    if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
        group_offset = {}
        t_planets_degut = {}
        if self.type == &#34;Transit&#34;:
            list_range = len(self.planets_settings)-4
        else:
            list_range = len(self.planets_settings)
        for i in range(list_range):
            group_offset[i] = 0
            if self.planets_settings[i][&#39;visible&#39;] == 1:
                t_planets_degut[self.t_planets_degree_ut[i]] = i
        t_keys = list(t_planets_degut.keys())
        t_keys.sort()

        # grab closely grouped planets
        groups = []
        in_group = False
        for e in range(len(t_keys)):
            i_a = t_planets_degut[t_keys[e]]
            if e == (len(t_keys)-1):
                i_b = t_planets_degut[t_keys[0]]
            else:
                i_b = t_planets_degut[t_keys[e+1]]

            a = self.t_planets_degree_ut[i_a]
            b = self.t_planets_degree_ut[i_b]
            diff = self.degreeDiff(a, b)
            if diff &lt;= 2.5:
                if in_group:
                    groups[-1].append(i_b)
                else:
                    groups.append([i_a])
                    groups[-1].append(i_b)
                    in_group = True
            else:
                in_group = False
        # loop groups and set degrees display adjustment
        for i in range(len(groups)):
            if len(groups[i]) == 2:
                group_offset[groups[i][0]] = -1.0
                group_offset[groups[i][1]] = 1.0
            elif len(groups[i]) == 3:
                group_offset[groups[i][0]] = -1.5
                group_offset[groups[i][1]] = 0
                group_offset[groups[i][2]] = 1.5
            elif len(groups[i]) == 4:
                group_offset[groups[i][0]] = -2.0
                group_offset[groups[i][1]] = -1.0
                group_offset[groups[i][2]] = 1.0
                group_offset[groups[i][3]] = 2.0

        switch = 0
        for e in range(len(t_keys)):
            i = t_planets_degut[t_keys[e]]

            if 22 &lt; i &lt; 27:
                rplanet = 9
            elif switch == 1:
                rplanet = 18
                switch = 0
            else:
                rplanet = 26
                switch = 1

            zeropoint = 360 - self.houses_degree_ut[6]
            t_offset = zeropoint + self.t_planets_degree_ut[i]
            if t_offset &gt; 360:
                t_offset = t_offset - 360
            planet_x = self.sliceToX(0, (r-rplanet), t_offset) + rplanet
            planet_y = self.sliceToY(0, (r-rplanet), t_offset) + rplanet
            output = output + &#39;&lt;g transform=&#34;translate(-6,-6)&#34;&gt;&lt;g transform=&#34;scale(0.5)&#34;&gt;&lt;use x=&#34;&#39; + str(
                planet_x*2) + &#39;&#34; y=&#34;&#39; + str(planet_y*2) + &#39;&#34; xlink:href=&#34;#&#39; + self.planets_settings[i][&#39;name&#39;] + &#39;&#34; /&gt;&lt;/g&gt;&lt;/g&gt;\n&#39;
            # transit planet line
            x1 = self.sliceToX(0, r+3, t_offset) - 3
            y1 = self.sliceToY(0, r+3, t_offset) - 3
            x2 = self.sliceToX(0, r-3, t_offset) + 3
            y2 = self.sliceToY(0, r-3, t_offset) + 3
            output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
                y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 1px; stroke-opacity:.8;&#34;/&gt;\n&#39;

            # transit planet degree text
            rotate = self.houses_degree_ut[0] - self.t_planets_degree_ut[i]
            textanchor = &#34;end&#34;
            t_offset += group_offset[i]
            rtext = -3.0

            if -90 &gt; rotate &gt; -270:
                rotate = rotate + 180.0
                textanchor = &#34;start&#34;
            if 270 &gt; rotate &gt; 90:
                rotate = rotate - 180.0
                textanchor = &#34;start&#34;

            if textanchor == &#34;end&#34;:
                xo = 1
            else:
                xo = -1
            deg_x = self.sliceToX(0, (r-rtext), t_offset + xo) + rtext
            deg_y = self.sliceToY(0, (r-rtext), t_offset + xo) + rtext
            degree = int(t_offset)
            output += &#39;&lt;g transform=&#34;translate(%s,%s)&#34;&gt;&#39; % (deg_x, deg_y)
            output += &#39;&lt;text transform=&#34;rotate(%s)&#34; text-anchor=&#34;%s&#39; % (
                rotate, textanchor)
            output += &#39;&#34; style=&#34;fill: &#39; + \
                self.planets_settings[i][&#39;color&#39;]+&#39;; font-size: 10px;&#34;&gt;&#39; + \
                self.dec2deg(self.t_planets_degree[i], type=&#34;1&#34;)
            output += &#39;&lt;/text&gt;&lt;/g&gt;\n&#39;

        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 36
        else:
            dropin = 0

        # planet line
        x1 = self.sliceToX(0, r-(dropin+3), offset) + (dropin+3)
        y1 = self.sliceToY(0, r-(dropin+3), offset) + (dropin+3)
        x2 = self.sliceToX(0, (r-(dropin-3)), offset) + (dropin-3)
        y2 = self.sliceToY(0, (r-(dropin-3)), offset) + (dropin-3)
        output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
            y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 2px; stroke-opacity:.6;&#34;/&gt;\n&#39;

        # check transit
        if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
            dropin = 160
        else:
            dropin = 120

        x1 = self.sliceToX(0, r-dropin, offset) + dropin
        y1 = self.sliceToY(0, r-dropin, offset) + dropin
        x2 = self.sliceToX(0, (r-(dropin-3)), offset) + (dropin-3)
        y2 = self.sliceToY(0, (r-(dropin-3)), offset) + (dropin-3)
        output = output + &#39;&lt;line x1=&#34;&#39;+str(x1)+&#39;&#34; y1=&#34;&#39;+str(y1)+&#39;&#34; x2=&#34;&#39;+str(x2)+&#39;&#34; y2=&#34;&#39;+str(
            y2)+&#39;&#34; style=&#34;stroke: &#39;+self.planets_settings[i][&#39;color&#39;]+&#39;; stroke-width: 2px; stroke-opacity:.6;&#34;/&gt;\n&#39;

    return output</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeSVG"><code class="name flex">
<span>def <span class="ident">makeSVG</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints out the SVG file in the specifide folder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeSVG(self):
    &#34;&#34;&#34;Prints out the SVG file in the specifide folder&#34;&#34;&#34;

    if not (self.template):
        self.template = self.makeTemplate()

    self.chartname = self.output_directory / f&#39;{self.name}{self.type}Chart.svg&#39;

    with open(self.chartname, &#34;w&#34;, encoding=&#39;utf-8&#39;) as output_file:
        output_file.write(self.template)

    return print(f&#34;SVG Generated Correctly in: {self.chartname}&#34;)</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeTemplate"><code class="name flex">
<span>def <span class="ident">makeTemplate</span></span>(<span>self, printing=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeTemplate(self, printing=None):
    # self.type = &#34;Transit&#34;
    # empty element points
    self.fire = 0.0
    self.earth = 0.0
    self.air = 0.0
    self.water = 0.0

    # Transit module data
    if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
        # grab transiting module data

        self.t_planets_sign = self.t_points_sign
        self.t_planets_degree = self.t_points_deg
        self.t_planets_degree_ut = self.t_points_deg_ut
        self.t_planets_retrograde = self.t_points_retrograde
        self.t_houses_list = self.t_user.houses_list
        self.t_houses_sign = self.t_houses_sign_graph
        self.t_houses_degree_ut = self.t_user.houses_degree_ut

    # grab normal module data
    self.planets_sign = self.points_sign
    self.planets_degree = self.points_deg
    self.planets_degree_ut = self.points_deg_ut
    self.planets_retrograde = self.points_retrograde
    self.houses_list = self.user.houses_list
    self.houses_sign = self.houses_sign_graph
    self.houses_degree_ut = self.user.houses_degree_ut
    self.lunar_phase = self.user.lunar_phase
    #

    # width and height from screen
    ratio = float(self.screen_width) / float(self.screen_height)
    if ratio &lt; 1.3:  # 1280x1024
        wm_off = 130
    else:  # 1024x768, 800x600, 1280x800, 1680x1050
        wm_off = 100

    # Viewbox and sizing
    svgHeight = &#34;100%&#34;  # self.screen_height-wm_off
    svgWidth = &#34;100%&#34;  #  self.screen_width-5.0
    # svgHeight=self.screen_height-wm_off
    # svgWidth=(770.0*svgHeight)/540.0
    # svgWidth=float(self.screen_width)-25.0
    rotate = &#34;0&#34;
    translate = &#34;0&#34;
    # Defoult:
    # viewbox = &#39;0 0 772.2 546.0&#39; #297mm * 2.6 + 210mm * 2.6
    if self.type == &#34;Natal&#34;:
        viewbox = &#39;0 0 772.2 546.0&#39;  # 297mm * 2.6 + 210mm * 2.6
    else:
        viewbox = &#39;0 0 1000 546.0&#39;

    # template dictionary
    td = dict()
    r = 240
    self.c1 = 0
    self.c2 = 36
    self.c3 = 120

    # transit
    if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
        td[&#39;transitRing&#39;] = self.transitRing(r)
        td[&#39;degreeRing&#39;] = self.degreeTransitRing(r)
        # circles
        td[&#39;c1&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
            str(r) + &#39;&#34; r=&#34;&#39; + str(r-36) + &#39;&#34;&#39;
        td[&#39;c1style&#39;] = &#39;fill: none; stroke: %s; stroke-width: 1px; stroke-opacity:.4;&#39; % (
            self.colors_settings[&#39;zodiac_transit_ring_2&#39;])
        td[&#39;c2&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
            str(r) + &#39;&#34; r=&#34;&#39; + str(r-72) + &#39;&#34;&#39;
        td[&#39;c2style&#39;] = &#39;fill: %s; fill-opacity:.4; stroke: %s; stroke-opacity:.4; stroke-width: 1px&#39; % (
            self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_transit_ring_1&#39;])
        td[&#39;c3&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
            str(r) + &#39;&#34; r=&#34;&#39; + str(r-160) + &#39;&#34;&#39;
        td[&#39;c3style&#39;] = &#39;fill: %s; fill-opacity:.8; stroke: %s; stroke-width: 1px&#39; % (
            self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_transit_ring_0&#39;])
        td[&#39;makeAspects&#39;] = self.makeAspectsTransit(r, (r-160))
        td[&#39;makeAspectGrid&#39;] = self.makeAspectTransitGrid(r)
        td[&#39;makePatterns&#39;] = &#39;&#39;
        td[&#39;chart_width&#39;] = self.full_width
    else:
        td[&#39;transitRing&#39;] = &#34;&#34;
        td[&#39;degreeRing&#39;] = self.degreeRing(r)
        # circles
        td[&#39;c1&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
            str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c1) + &#39;&#34;&#39;
        td[&#39;c1style&#39;] = &#39;fill: none; stroke: %s; stroke-width: 1px; &#39; % (
            self.colors_settings[&#39;zodiac_radix_ring_2&#39;])
        td[&#39;c2&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
            str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c2) + &#39;&#34;&#39;
        td[&#39;c2style&#39;] = &#39;fill: %s; fill-opacity:.2; stroke: %s; stroke-opacity:.4; stroke-width: 1px&#39; % (
            self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_radix_ring_1&#39;])
        td[&#39;c3&#39;] = &#39;cx=&#34;&#39; + str(r) + &#39;&#34; cy=&#34;&#39; + \
            str(r) + &#39;&#34; r=&#34;&#39; + str(r-self.c3) + &#39;&#34;&#39;
        td[&#39;c3style&#39;] = &#39;fill: %s; fill-opacity:.8; stroke: %s; stroke-width: 1px&#39; % (
            self.colors_settings[&#39;paper_1&#39;], self.colors_settings[&#39;zodiac_radix_ring_0&#39;])
        td[&#39;makeAspects&#39;] = self.makeAspects(r, (r-self.c3))
        td[&#39;makeAspectGrid&#39;] = self.makeAspectGrid(r)
        td[&#39;makePatterns&#39;] = self.makePatterns()
        td[&#39;chart_width&#39;] = self.natal_width

    td[&#39;circleX&#39;] = str(0)
    td[&#39;circleY&#39;] = str(0)
    td[&#39;svgWidth&#39;] = str(svgWidth)
    td[&#39;svgHeight&#39;] = str(svgHeight)
    td[&#39;viewbox&#39;] = viewbox
    if self.type == &#34;Composite&#34;:
        td[&#39;stringTitle&#39;] = f&#34;{self.name} {self.language_settings[&#39;&amp;&#39;]} {self.t_user.name}&#34;
    elif self.type == &#34;Transit&#34;:
        td[&#39;stringTitle&#39;] = f&#34;{self.language_settings[&#39;transits&#39;]} {self.t_user.day}/{self.t_user.month}/{self.t_user.year}&#34;
    else:
        td[&#39;stringTitle&#39;] = self.name

    # Tipo di carta
    if self.type == &#34;Composite&#34; or self.name == &#34;Transit&#34;:
        td[&#39;stringName&#39;] = f&#34;{self.name}:&#34;
    else:
        td[&#39;stringName&#39;] = f&#39;{self.language_settings[&#34;info&#34;]}:&#39;

    # bottom left

    td[&#39;bottomLeft1&#39;] = &#39;&#39;
    td[&#39;bottomLeft2&#39;] = &#39;&#39;
    td[&#39;bottomLeft3&#39;] = f&#39;{self.language_settings.get(&#34;lunar_phase&#34;, &#34;Lunar Phase&#34;)}: {self.language_settings.get(&#34;day&#34;, &#34;Day&#34;)} {self.lunar_phase.get(&#34;moon_phase&#34;, &#34;&#34;)}&#39;
    td[&#39;bottomLeft4&#39;] = &#39;&#39;

    # lunar phase
    deg = self.lunar_phase[&#39;degrees_between_s_m&#39;]

    if(deg &lt; 90.0):
        maxr = deg
        if(deg &gt; 80.0):
            maxr = maxr*maxr
        lfcx = 20.0+(deg/90.0)*(maxr+10.0)
        lfr = 10.0+(deg/90.0)*maxr
        lffg, lfbg = self.colors_settings[&#34;lunar_phase_0&#34;], self.colors_settings[&#34;lunar_phase_1&#34;]

    elif(deg &lt; 180.0):
        maxr = 180.0-deg
        if(deg &lt; 100.0):
            maxr = maxr*maxr
        lfcx = 20.0+((deg-90.0)/90.0*(maxr+10.0))-(maxr+10.0)
        lfr = 10.0+maxr-((deg-90.0)/90.0*maxr)
        lffg, lfbg = self.colors_settings[&#34;lunar_phase_1&#34;], self.colors_settings[&#34;lunar_phase_0&#34;]

    elif(deg &lt; 270.0):
        maxr = deg-180.0
        if(deg &gt; 260.0):
            maxr = maxr*maxr
        lfcx = 20.0+((deg-180.0)/90.0*(maxr+10.0))
        lfr = 10.0+((deg-180.0)/90.0*maxr)
        lffg, lfbg = self.colors_settings[&#34;lunar_phase_1&#34;], self.colors_settings[&#34;lunar_phase_0&#34;]

    elif(deg &lt; 361):
        maxr = 360.0-deg
        if(deg &lt; 280.0):
            maxr = maxr*maxr
        lfcx = 20.0+((deg-270.0)/90.0*(maxr+10.0))-(maxr+10.0)
        lfr = 10.0+maxr-((deg-270.0)/90.0*maxr)
        lffg, lfbg = self.colors_settings[&#34;lunar_phase_0&#34;], self.colors_settings[&#34;lunar_phase_1&#34;]

    td[&#39;lunar_phase_fg&#39;] = lffg
    td[&#39;lunar_phase_bg&#39;] = lfbg
    td[&#39;lunar_phase_cx&#39;] = lfcx
    td[&#39;lunar_phase_r&#39;] = lfr
    td[&#39;lunar_phase_outline&#39;] = self.colors_settings[&#34;lunar_phase_2&#34;]

    # rotation based on latitude
    td[&#39;lunar_phase_rotate&#39;] = (-90.0-self.geolat)

    # stringlocation
    if len(self.location) &gt; 35:
        split = self.location.split(&#34;,&#34;)
        if len(split) &gt; 1:
            td[&#39;stringLocation&#39;] = split[0]+&#34;, &#34;+split[-1]
            if len(td[&#39;stringLocation&#39;]) &gt; 35:
                td[&#39;stringLocation&#39;] = td[&#39;stringLocation&#39;][:35]+&#34;...&#34;
        else:
            td[&#39;stringLocation&#39;] = self.location[:35]+&#34;...&#34;
    else:
        td[&#39;stringLocation&#39;] = self.location

    # td[&#39;stringDateTime&#39;]= str(self.user.year)+&#39;-%(#1)02d-%(#2)02d %(#3)02d:%(#4)02d:%(#5)02d&#39; % {&#39;#1&#39;:self.user.month,&#39;#2&#39;:self.user.day,&#39;#3&#39;:self.user.hours,&#39;#4&#39;:self.user.minuts,&#39;#5&#39;:00} + self.decTzStr(self.timezone)
    td[&#39;stringDateTime&#39;] = f&#39;{self.user.year}-{self.user.month}-{self.user.day} {self.user.hours:02d}:{self.user.minuts:02d}&#39;

    if self.type == &#34;Composite&#34;:
        td[&#39;stringLat&#39;] = f&#39;{self.t_user.name}: &#39;
        td[&#39;stringLon&#39;] = self.t_user.city
        td[&#39;stringPosition&#39;] = f&#39;{self.t_user.year}-{self.t_user.month}-{self.t_user.day} {self.t_user.hours:02d}:{self.t_user.minuts:02d}&#39;

    else:
        td[&#39;stringLat&#39;] = &#34;%s: %s&#34; % (
            self.language_settings[&#39;latitude&#39;], self.lat2str(self.geolat))
        td[&#39;stringLon&#39;] = &#34;%s: %s&#34; % (
            self.language_settings[&#39;longitude&#39;], self.lon2str(self.geolon))
        td[&#39;stringPosition&#39;] = f&#34;{self.language_settings[&#39;type&#39;]}: {self.charttype}&#34;

    # paper_color_X
    td[&#39;paper_color_0&#39;] = self.colors_settings[&#34;paper_0&#34;]
    td[&#39;paper_color_1&#39;] = self.colors_settings[&#34;paper_1&#34;]

    # planets_color_X
    for i in range(len(self.planets_settings)):
        td[&#39;planets_color_%s&#39; %
            (i)] = self.colors_settings[&#34;planet_%s&#34; % (i)]

    # zodiac_color_X
    for i in range(12):
        td[&#39;zodiac_color_%s&#39; %
            (i)] = self.colors_settings[&#34;zodiac_icon_%s&#34; % (i)]

    # orb_color_X
    for i in range(len(self.aspects_settings)):
        td[&#39;orb_color_%s&#39; % (self.aspects_settings[i][&#39;degree&#39;])] = self.colors_settings[&#34;aspect_%s&#34; % (
            self.aspects_settings[i][&#39;degree&#39;])]

    # config
    td[&#39;cfgZoom&#39;] = str(self.zoom)
    td[&#39;cfgRotate&#39;] = rotate
    td[&#39;cfgTranslate&#39;] = translate

    # functions
    td[&#39;makeZodiac&#39;] = self.makeZodiac(r)
    td[&#39;makeHouses&#39;] = self.makeHouses(r)
    td[&#39;makePlanets&#39;] = self.makePlanets(r)
    td[&#39;makeElements&#39;] = self.makeElements(r)
    td[&#39;makePlanetGrid&#39;] = self.makePlanetGrid()
    td[&#39;makeHousesGrid&#39;] = self.makeHousesGrid()

    # read template
    with open(self.xml_svg, &#34;r&#34;) as output_file:
        f = open(self.xml_svg)
        template = Template(f.read()).substitute(td)

    # return filename

    return template</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeZodiac"><code class="name flex">
<span>def <span class="ident">makeZodiac</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeZodiac(self, r):
    output = &#34;&#34;
    for i in range(len(self.zodiac)):
        output = output + self.zodiacSlice(i, r, &#34;fill:&#34; + self.colors_settings[&#34;zodiac_bg_%s&#34; % (
            i)] + &#34;; fill-opacity: 0.5;&#34;, self.zodiac[i]) + &#39;\n&#39;
    return output</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.offsetToTz"><code class="name flex">
<span>def <span class="ident">offsetToTz</span></span>(<span>self, dtoffset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offsetToTz(self, dtoffset):
    dh = float(dtoffset.days * 24)
    sh = float(dtoffset.seconds / 3600.0)
    output = dh + sh
    return output</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.parse_json_settings"><code class="name flex">
<span>def <span class="ident">parse_json_settings</span></span>(<span>self, settings_file, lang: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the settings file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_json_settings(self, settings_file, lang: str):
    &#34;&#34;&#34;
    Parse the settings file.
    &#34;&#34;&#34;
    with open(settings_file, &#39;r&#39;) as f:
        settings = json.load(f)

    self.language_settings = settings[&#39;language_settings&#39;].get(
        lang, &#34;EN&#34;)
    self.colors_settings = settings[&#39;colors&#39;]
    self.planets_settings = settings[&#39;planets&#39;]
    self.aspects_settings = settings[&#39;aspects&#39;]</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.set_output_directory"><code class="name flex">
<span>def <span class="ident">set_output_directory</span></span>(<span>self, dir_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the output direcotry and returns it's path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_output_directory(self, dir_path):
    &#34;&#34;&#34;
    Sets the output direcotry and returns it&#39;s path.
    &#34;&#34;&#34;
    self.output_directory = Path(dir_path)
    dir_string = f&#34;Output direcotry set to: {self.output_directory}&#34;
    return (print(dir_string))</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.sliceToX"><code class="name flex">
<span>def <span class="ident">sliceToX</span></span>(<span>self, slice, r, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sliceToX(self, slice, r, offset):
    plus = (math.pi * offset) / 180
    radial = ((math.pi/6) * slice) + plus
    return r * (math.cos(radial)+1)</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.sliceToY"><code class="name flex">
<span>def <span class="ident">sliceToY</span></span>(<span>self, slice, r, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sliceToY(self, slice, r, offset):
    plus = (math.pi * offset) / 180
    radial = ((math.pi/6) * slice) + plus
    return r * ((math.sin(radial)/-1)+1)</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.transitRing"><code class="name flex">
<span>def <span class="ident">transitRing</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transitRing(self, r):
    out = &#39;&lt;circle cx=&#34;%s&#34; cy=&#34;%s&#34; r=&#34;%s&#34; style=&#34;fill: none; stroke: %s; stroke-width: 36px; stroke-opacity: .4;&#34;/&gt;&#39; % (
        r, r, r-18, self.colors_settings[&#39;paper_1&#39;])
    out += &#39;&lt;circle cx=&#34;%s&#34; cy=&#34;%s&#34; r=&#34;%s&#34; style=&#34;fill: none; stroke: %s; stroke-width: 1px; stroke-opacity: .6;&#34;/&gt;&#39; % (
        r, r, r, self.colors_settings[&#39;zodiac_transit_ring_3&#39;])
    return out</code></pre>
</details>
</dd>
<dt id="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.zodiacSlice"><code class="name flex">
<span>def <span class="ident">zodiacSlice</span></span>(<span>self, num, r, style, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zodiacSlice(self, num, r, style,  type):
    # pie slices
    offset = 360 - self.houses_degree_ut[6]
    # check transit
    if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
        dropin = 0
    else:
        dropin = self.c1
    slice = &#39;&lt;path d=&#34;M&#39; + str(r) + &#39;,&#39; + str(r) + &#39; L&#39; + str(dropin + self.sliceToX(num, r-dropin, offset)) + &#39;,&#39; + str(dropin + self.sliceToY(num, r-dropin, offset)) + &#39; A&#39; + str(
        r-dropin) + &#39;,&#39; + str(r-dropin) + &#39; 0 0,0 &#39; + str(dropin + self.sliceToX(num+1, r-dropin, offset)) + &#39;,&#39; + str(dropin + self.sliceToY(num+1, r-dropin, offset)) + &#39; z&#34; style=&#34;&#39; + style + &#39;&#34;/&gt;&#39;
    # symbols
    offset = offset + 15
    # check transit
    if self.type == &#34;Transit&#34; or self.type == &#34;Composite&#34;:
        dropin = 54
    else:
        dropin = 18+self.c1
    sign = &#39;&lt;g transform=&#34;translate(-16,-16)&#34;&gt;&lt;use x=&#34;&#39; + str(dropin + self.sliceToX(num, r-dropin, offset)) + &#39;&#34; y=&#34;&#39; + str(
        dropin + self.sliceToY(num, r-dropin, offset)) + &#39;&#34; xlink:href=&#34;#&#39; + type + &#39;&#34; /&gt;&lt;/g&gt;\n&#39;
    return slice + &#39;\n&#39; + sign</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="kerykeion.utilities.charts" href="index.html">kerykeion.utilities.charts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance">MakeSvgInstance</a></code></h4>
<ul class="">
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.dec2deg" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.dec2deg">dec2deg</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decHour" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decHour">decHour</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decHourJoin" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decHourJoin">decHourJoin</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decTzStr" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.decTzStr">decTzStr</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeDiff" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeDiff">degreeDiff</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeRing" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeRing">degreeRing</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeTransitRing" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.degreeTransitRing">degreeTransitRing</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.drawAspect" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.drawAspect">drawAspect</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.lat2str" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.lat2str">lat2str</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.lon2str" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.lon2str">lon2str</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectGrid" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectGrid">makeAspectGrid</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectTransitGrid" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectTransitGrid">makeAspectTransitGrid</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspects" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspects">makeAspects</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectsTransit" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeAspectsTransit">makeAspectsTransit</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeElements" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeElements">makeElements</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeHouses" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeHouses">makeHouses</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeHousesGrid" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeHousesGrid">makeHousesGrid</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePatterns" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePatterns">makePatterns</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePlanetGrid" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePlanetGrid">makePlanetGrid</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePlanets" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makePlanets">makePlanets</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeSVG" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeSVG">makeSVG</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeTemplate" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeTemplate">makeTemplate</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeZodiac" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.makeZodiac">makeZodiac</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.offsetToTz" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.offsetToTz">offsetToTz</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.parse_json_settings" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.parse_json_settings">parse_json_settings</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.set_output_directory" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.set_output_directory">set_output_directory</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.sliceToX" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.sliceToX">sliceToX</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.sliceToY" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.sliceToY">sliceToY</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.transitRing" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.transitRing">transitRing</a></code></li>
<li><code><a title="kerykeion.utilities.charts.charts_svg.MakeSvgInstance.zodiacSlice" href="#kerykeion.utilities.charts.charts_svg.MakeSvgInstance.zodiacSlice">zodiacSlice</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>